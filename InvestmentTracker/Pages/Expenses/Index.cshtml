@page
@model InvestmentTracker.Pages.Expenses.IndexModel
@using System.Text.Json
@using System.Linq
@using InvestmentTracker.Models
@{
    // currentDate already declared above if needed
    // ViewData["Title"] is set below based on schedule type
}

@{
    // Variables declared below in main heading block
}

@{
    var scheduleConfig = Model.ViewModel.ScheduleConfig;
    string activeScheduleType = scheduleConfig?.ScheduleType ?? "Calendar";
    int activeStartDay = scheduleConfig?.StartDay ?? 1;
    string headingText;
    if (activeScheduleType == "Custom")
    {
        var startDate = Model.ViewModel.FinancialMonthStartDate;
        var endDate = Model.ViewModel.FinancialMonthEndDate;
        headingText = $"Expenses: {startDate:dd MMM yyyy} â€“ {endDate:dd MMM yyyy}";
        ViewData["Title"] = headingText;
    }
    else
    {
        var currentDate = new DateTime(Model.ViewModel.SelectedDate.Year, Model.ViewModel.SelectedDate.Month, 1);
        headingText = $"Monthly Expenses - {currentDate:MMMM yyyy}";
        ViewData["Title"] = headingText;
    }

    var allExpenseCategories = (await Model.GetExpenseCategoriesAsync())
        .OrderBy(category => category.Name, StringComparer.OrdinalIgnoreCase)
        .ToList();
}

<style>
    .import-invalid-cell {
        border-left: 4px solid var(--bs-danger);
        background-color: transparent;
    }

    .import-invalid-hint {
        color: var(--bs-danger);
    }

    .import-detection-note {
        color: var(--bs-secondary);
        font-style: italic;
    }

    .import-missing-header {
        color: var(--bs-body-color);
        border-bottom: 2px solid var(--bs-danger);
    }

    .import-optional-header {
        color: var(--bs-body-color);
        border-bottom: 2px solid rgba(220, 53, 69, 0.4);
    }

    .duplicate-row {
        position: relative;
        background-color: rgba(13, 110, 253, 0.08) !important;
        border-left: 4px solid rgba(13, 202, 240, 0.8);
        box-shadow: inset 0 0 0 1px rgba(13, 110, 253, 0.15);
    }

    .duplicate-badge {
        display: inline-flex;
        align-items: center;
        gap: 0.35rem;
        padding: 0.15rem 0.65rem;
        font-size: 0.75em;
        font-weight: 600;
        text-transform: uppercase;
        background-color: rgba(13, 202, 240, 0.18);
        color: var(--bs-body-color);
        border-radius: 999px;
        border: 1px solid rgba(13, 110, 253, 0.2);
        letter-spacing: 0.05em;
    }

</style>

<div class="d-block d-lg-flex align-items-lg-center justify-content-lg-between mb-3">
    <div class="d-flex flex-wrap align-items-center justify-content-center justify-content-lg-start mb-3 mb-lg-0">
        <h2 class="mb-0 me-3 text-center">@headingText</h2>
    </div>
    <form method="get" class="d-flex flex-wrap align-items-end justify-content-center justify-content-lg-end gap-2 mb-0">
        <div>
            <label for="monthPicker" class="form-label mb-0">Month</label>
            <input type="date" id="monthPicker" name="selectedDate" class="form-control" value="@Model.ViewModel.SelectedDate.ToString("yyyy-MM-dd")" />
        </div>
        <button type="submit" class="btn btn-primary">Update View</button>
        <div class="btn-group ms-2" role="group">
            <button type="button" class="btn btn-secondary" onclick="navigateMonth(-1)" title="Previous Month">
                <i class="bi bi-chevron-left"></i> Previous
            </button>
            <button type="button" class="btn btn-primary" onclick="navigateToCurrentMonth()" title="Current Month">
                <i class="bi bi-calendar-event"></i>
                <span class="d-none d-sm-inline ms-1">Current</span>
            </button>
            <button type="button" class="btn btn-secondary" onclick="navigateMonth(1)" title="Next Month">
                Next <i class="bi bi-chevron-right"></i>
            </button>
        </div>
        
        <!-- Unified Schedule Dropdown -->
        <div class="btn-group ms-3">
            <button type="button" class="btn btn-outline-secondary dropdown-toggle" data-bs-toggle="dropdown" aria-expanded="false">
                <i class="bi bi-calendar3 me-1"></i>
                Schedule: @activeScheduleType
            </button>
            <ul class="dropdown-menu dropdown-menu-end">
                <li><a class="dropdown-item" href="/expenses/financialscheduleconfig">Configure Financial Schedule</a></li>
                @if (activeScheduleType == "Custom")
                {
                    <li><hr class="dropdown-divider"></li>
                    <li>
                        <button class="dropdown-item" type="button" data-bs-toggle="modal" data-bs-target="#adjustStartDateModal">
                            Adjust Current Month
                        </button>
                    </li>
                }
            </ul>
        </div>
        <button type="button" class="btn btn-outline-primary" data-bs-toggle="modal" data-bs-target="#importStatementModal">
            <i class="bi bi-cloud-upload me-1"></i>
            Import Statement
        </button>
    </form>
</div>

<div class="row mb-4">
    <div class="col-md-4">
        <div class="card text-center">
            <div class="card-body">
                <h5 class="card-title text-success">@Model.ViewModel.TotalIncome.ToString("C", new System.Globalization.CultureInfo("cs-CZ"))</h5>
                <p class="card-text">Total Income</p>
            </div>
        </div>
    </div>
    <div class="col-md-4">
        <div class="card text-center">
            <div class="card-body">
                <h5 class="card-title text-danger">@Model.ViewModel.TotalExpenses.ToString("C", new System.Globalization.CultureInfo("cs-CZ"))</h5>
                <p class="card-text">Total Expenses</p>
            </div>
        </div>
    </div>
    <div class="col-md-4">
        <div class="card text-center">
            <div class="card-body">
                <h5 class="card-title @(Model.ViewModel.NetBalance >= 0 ? "text-primary" : "text-warning")">@Model.ViewModel.NetBalance.ToString("C", new System.Globalization.CultureInfo("cs-CZ"))</h5>
                <p class="card-text">Net Balance</p>
            </div>
        </div>
    </div>
</div>

<!-- Restore: Regular and One-Time Incomes row (unchanged original content) -->
<div class="row mt-4">
    <div class="col-md-6">
        <div class="card">
            <div class="card-header d-flex justify-content-between align-items-center">
                <button class="btn btn-sm btn-link p-0 text-decoration-none text-body d-flex align-items-center" type="button" data-bs-toggle="collapse" data-bs-target="#regularIncomesCollapse" aria-expanded="false" aria-controls="regularIncomesCollapse" id="regularIncomesToggleBtn" aria-label="Toggle Regular Incomes" title="Collapse/Expand">
                    <i class="bi bi-caret-down-fill me-1" id="regularIncomesChevron"></i>
                    <span class="fw-semibold">Regular Incomes</span>
                </button>
                <a asp-page="./IncomeSources" class="btn btn-sm btn-primary">
                    <i class="bi bi-gear"></i>
                    <span class="d-none d-sm-inline ms-2">Manage Income Sources</span>
                </a>
            </div>
            <div class="card-body collapse" id="regularIncomesCollapse">
                <div class="table-responsive">
                <table class="table table-striped mb-0">
                    <thead>
                        <tr>
                            <th>Source</th>
                            <th>Expected</th>
                            <th>Actual</th>
                            <th></th>
                        </tr>
                    </thead>
                    <tbody>
                        @foreach (var income in Model.ViewModel.Incomes)
                        {
                            <tr>
                                <td colspan="4" style="padding:0;">
                                    <form method="post" asp-page-handler="UpdateIncome" data-loading="Updating income..." style="margin:0;">
                                        <div class="row g-0 align-items-center">
                                            <div class="col">@income.Name</div>
                                            <div class="col">@income.ExpectedAmount.ToString("C", new System.Globalization.CultureInfo(income.Currency.ToCultureCode()))</div>
                                            <div class="col">
                                                <input type="text" name="actualAmount" value="@income.ActualAmount" class="form-control" />
                                                <input type="hidden" name="incomeSourceId" value="@income.IncomeSourceId" />
                                                <input type="hidden" name="year" value="@Model.ViewModel.SelectedDate.Year" />
                                                <input type="hidden" name="month" value="@Model.ViewModel.SelectedDate.Month" />
                                            </div>
                                            <div class="col">
                                                <button type="submit" class="btn btn-sm btn-primary ms-2" title="Update" aria-label="Update">
                                                    <i class="bi bi-save"></i>
                                                </button>
                                            </div>
                                        </div>
                                    </form>
                                </td>
                            </tr>
                        }
                    </tbody>
                </table>
                </div>
            </div>
        </div>
    </div>
    <div class="col-md-6">
        <div class="card">
            <div class="card-header d-flex justify-content-between align-items-center">
                <button class="btn btn-sm btn-link p-0 text-decoration-none text-body d-flex align-items-center" type="button" data-bs-toggle="collapse" data-bs-target="#oneTimeIncomesCollapse" aria-expanded="false" aria-controls="oneTimeIncomesCollapse" id="oneTimeIncomesToggleBtn" aria-label="Toggle One-Time Incomes" title="Collapse/Expand">
                    <i class="bi bi-caret-down-fill me-1" id="oneTimeIncomesChevron"></i>
                    <span class="fw-semibold">One-Time Incomes</span>
                </button>
                <button type="button" class="btn btn-sm btn-primary" data-bs-toggle="modal" data-bs-target="#addOneTimeIncomeModal" title="Add Income" aria-label="Add Income">
                    <i class="bi bi-plus-lg"></i>
                    <span class="d-none d-sm-inline ms-2">Add Income <kbd>O</kbd></span>
                </button>
            </div>
            <div class="card-body collapse" id="oneTimeIncomesCollapse">
                <div class="table-responsive">
                <table class="table table-striped mb-0">
                    <thead>
                        <tr>
                            <th>Date</th>
                            <th>Name</th>
                            <th>Source</th>
                            <th>Amount</th>
                            <th></th>
                        </tr>
                    </thead>
                    <tbody>
                        @if (Model.ViewModel.OneTimeIncomes.Any())
                        {
                            @foreach (var income in Model.ViewModel.OneTimeIncomes)
                            {
                                <tr>
                                    <td>@income.Date.ToString("dd/MM/yyyy")</td>
                                    <td>@income.Name</td>
                                    <td>@(income.IncomeSource?.Name ?? "Other")</td>
                                    <td>@income.Amount.ToString("C", new System.Globalization.CultureInfo(income.Currency.ToCultureCode()))</td>
                                    <td>
                                        <div class="d-flex flex-wrap align-items-center gap-2">
                                            <button type="button" class="btn btn-sm btn-secondary align-middle" onclick="editOneTimeIncome(@income.Id)" title="Edit" aria-label="Edit">
                                                <i class="bi bi-pencil"></i>
                                            </button>
                                            <form method="post" asp-page-handler="DeleteOneTimeIncome" asp-route-incomeId="@income.Id" class="d-inline" data-confirm="Delete this one-time income? This action cannot be undone." data-loading="Deleting income...">
                                                <input type="hidden" name="SelectedDate" value="@Model.ViewModel.SelectedDate.ToString("yyyy-MM-dd")" />
                                                <button type="submit" class="btn btn-sm btn-danger align-middle" title="Delete" aria-label="Delete">
                                                    <i class="bi bi-trash"></i>
                                                </button>
                                            </form>
                                        </div>
                                    </td>
                                </tr>
                            }
                        }
                        else
                        {
                            <tr>
                                <td colspan="5" class="text-center text-muted">No one-time incomes found. <a href="#" data-bs-toggle="modal" data-bs-target="#addOneTimeIncomeModal">Add your first income</a></td>
                            </tr>
                        }
                    </tbody>
                </table>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Budgets Card -->
<div class="card mb-4">
    <div class="card-header d-flex justify-content-between align-items-center">
        <button class="btn btn-sm btn-link p-0 text-decoration-none text-body d-flex align-items-center" type="button" data-bs-toggle="collapse" data-bs-target="#budgetsCollapse" aria-expanded="false" aria-controls="budgetsCollapse" id="budgetsToggleBtn" aria-label="Toggle Budgets" title="Collapse/Expand">
            <i class="bi bi-caret-down-fill me-1" id="budgetsChevron"></i>
            <span class="fw-semibold">Budgets</span>
        </button>
        <a href="./Budgets?year=@Model.ViewModel.SelectedDate.Year&month=@Model.ViewModel.SelectedDate.Month" class="btn btn-sm btn-primary">
            <i class="bi bi-gear"></i>
            <span class="d-none d-sm-inline ms-2">Manage Budgets</span>
        </a>
    </div>
    <div class="card-body collapse" id="budgetsCollapse">
        @if (Model.ViewModel.Budgets.Any(b => b.BudgetAmount.HasValue))
        {
            <div class="table-responsive">
                <table class="table table-striped align-middle mb-0">
                    <thead class="table-light">
                        <tr>
                            <th>Category</th>
                            <th class="text-end">Budget</th>
                            <th class="text-end">Spent</th>
                            <th style="width:40%">Progress</th>
                            <th>Status</th>
                        </tr>
                    </thead>
                    <tbody>
                    @foreach (var b in Model.ViewModel.Budgets.Where(b => b.BudgetAmount.HasValue).OrderByDescending(x => x.BudgetAmount.HasValue).ThenBy(x => x.CategoryName))
                    {
                        var percent = b.BudgetAmount.HasValue && b.BudgetAmount > 0 ? Math.Min(100, Math.Round(b.Percent)) : 0;
                        var barClass = b.Status == "Over" ? "bg-danger" : b.Status == "Near" ? "bg-warning" : "bg-primary";
                        <tr>
                            <td>@b.CategoryName</td>
                            <td class="text-end">@(b.BudgetAmount!.Value.ToString("N0", new System.Globalization.CultureInfo("cs-CZ")))</td>
                            <td class="text-end">@b.SpentAmount.ToString("N0", new System.Globalization.CultureInfo("cs-CZ"))</td>
                            <td>
                                <div class="progress" role="progressbar" aria-label=$"Spent {b.SpentAmount} of {b.BudgetAmount} ({percent}%)">
                                    <div class="progress-bar @barClass" style="width:@percent%">
                                        <span class="ms-2">@percent%</span>
                                    </div>
                                </div>
                                <small class="text-muted">
                                    @if (b.Percent >= 100)
                                    {
                                        <text>Over by @((b.SpentAmount - (b.BudgetAmount ?? 0)).ToString("N0", new System.Globalization.CultureInfo("cs-CZ")))</text>
                                    }
                                    else
                                    {
                                        <text>Remaining @(((b.BudgetAmount ?? 0) - b.SpentAmount).ToString("N0", new System.Globalization.CultureInfo("cs-CZ")))</text>
                                    }
                                </small>
                            </td>
                            <td>
                                <span class="badge @(b.Status == "Over" ? "bg-danger" : b.Status == "Near" ? "bg-warning text-dark" : "bg-primary")">@b.Status</span>
                            </td>
                        </tr>
                    }
                    </tbody>
                </table>
            </div>
        }
        else
        {
            <div class="text-center text-muted">
                No budgets set for this month.
            </div>
        }
    </div>
    <div class="card-footer text-muted small">
        Near threshold at 80%. Over at 100%. Leftover does not carry over.
    </div>
</div>

<div class="row mt-4">
    <div class="col-12 mb-3">
        <div class="card">
            <div class="card-header d-flex justify-content-between align-items-center">
                <div class="d-flex align-items-center gap-2">
                    <button class="btn btn-sm btn-link p-0 text-decoration-none text-body d-flex align-items-center" type="button" data-bs-toggle="collapse" data-bs-target="#regularExpensesCollapse" aria-expanded="false" aria-controls="regularExpensesCollapse" id="regularToggleBtn" aria-label="Toggle Regular Expenses" title="Collapse/Expand">
                        <i class="bi bi-caret-down-fill me-1" id="regularChevron"></i>
                        <span class="fw-semibold">Regular Expenses</span>
                    </button>
                    <small class="text-muted ms-1">
                        @("Total: " + Model.ViewModel.RegularExpenses.Sum(e => e.Amount).ToString("C", new System.Globalization.CultureInfo("cs-CZ")))
                    </small>
                </div>
                <div>
                    <button type="button" class="btn btn-sm btn-primary" data-bs-toggle="modal" data-bs-target="#addRegularExpenseModal" title="Add Expense" aria-label="Add Expense">
                        <i class="bi bi-plus-lg"></i>
                        <span class="d-none d-sm-inline ms-2">Add Expense <kbd>A</kbd></span>
                    </button>
                </div>
            </div>
            <div class="card-body collapse" id="regularExpensesCollapse">
                <div id="regularExpensesContainer">
                    <div class="table-responsive">
                    <table class="table table-striped mb-0" id="regularExpensesTable">
                        <thead>
                            <tr>
                                <th data-sort="text">Name</th>
                                <th data-sort="text">Category</th>
                                <th data-sort="number">Amount</th>
                                <th data-sort="text">Schedule</th>
                                <th data-sort="text">Type</th>
                                <th></th>
                            </tr>
                        </thead>
                        <tbody>
                            @if (Model.ViewModel.RegularExpenses.Any())
                            {
                                @foreach (var expense in Model.ViewModel.RegularExpenses)
                                {
                                    <tr class="fade-in">
                                        <td>
                                            @if (expense.IsAlternativeSchedule)
                                            {
                                                <i class="bi bi-calendar-event text-info me-1" title="@expense.FrequencyDisplay schedule - shows only in specific months" data-bs-toggle="tooltip"></i>
                                            }
                                            @expense.Name
                                        </td>
                                        <td>@(expense.Category?.Name ?? "Uncategorized")</td>
                                        <td>@expense.Amount.ToString("C", new System.Globalization.CultureInfo(expense.Currency.ToCultureCode()))</td>
                                        <td>
                                            @if (expense.FrequencyDisplay == "Monthly")
                                            {
                                                <span class="badge bg-primary">Monthly</span>
                                            }
                                            else
                                            {
                                                <span class="badge bg-warning text-dark">@expense.FrequencyDisplay</span>
                                            }
                                        </td>
                                        <td>
                                            <span class="badge bg-@(expense.ExpenseType == ExpenseType.Family ? "primary" : "secondary")">
                                                @if (expense.ExpenseType == ExpenseType.Family)
                                                {
                                                    <text>Family</text>
                                                }
                                                else
                                                {
                                                    @($"Individual: {expense.FamilyMember?.Name ?? "Unknown"}")
                                                }
                                            </span>
                                        </td>
                                        <td>
                                            <div class="d-flex flex-wrap align-items-center gap-2">
                                                <button type="button" class="btn btn-sm btn-secondary" onclick="editRegularExpense(@expense.Id)" title="Edit" aria-label="Edit">
                                                    <i class="bi bi-pencil"></i>
                                                </button>
                                                <form method="post" asp-page-handler="DeleteRegularExpense" asp-route-expenseId="@expense.Id" class="d-inline" data-confirm="Delete this regular expense? This action cannot be undone." data-loading="Deleting expense...">
                                                    <input type="hidden" name="SelectedDate" value="@Model.ViewModel.SelectedDate.ToString("yyyy-MM-dd")" />
                                                    <button type="submit" class="btn btn-sm btn-danger align-middle" title="Delete" aria-label="Delete">
                                                        <i class="bi bi-trash"></i>
                                                    </button>
                                                </form>
                                            </div>
                                        </td>
                                    </tr>
                                }
                            }
                    </table>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="col-12">
         <div class="card">
             <div class="card-header d-flex justify-content-between align-items-center">
                 <div class="d-flex align-items-center gap-2">
                     <button class="btn btn-sm btn-link p-0 text-decoration-none text-body d-flex align-items-center" type="button" data-bs-toggle="collapse" data-bs-target="#irregularExpensesCollapse" aria-expanded="true" aria-controls="#irregularExpensesCollapse" id="irregularToggleBtn" aria-label="Toggle One-Time Expenses" title="Collapse/Expand">
                         <i class="bi bi-caret-down-fill me-1" id="irregularChevron"></i>
                         <span class="fw-semibold">One-Time Expenses</span>
                     </button>
                     <small class="text-muted ms-1">
                         @("Total: " + Model.ViewModel.IrregularExpenses.Sum(e => e.Amount).ToString("C", new System.Globalization.CultureInfo("cs-CZ")))
                     </small>
                 </div>
                 <div>
                     <button type="button" class="btn btn-sm btn-primary" data-bs-toggle="modal" data-bs-target="#addIrregularExpenseModal" title="Add One-Time Expense" aria-label="Add One-Time Expense">
                         <i class="bi bi-plus-lg"></i>
                         <span class="d-none d-sm-inline ms-2">Add One-Time Expense <kbd>Q</kbd></span>
                     </button>
                 </div>
             </div>
             <div class="card-body collapse show" id="irregularExpensesCollapse">
                 <div id="irregularExpensesContainer">
                     <div class="table-responsive">
                     <table class="table table-striped mb-0" id="irregularExpensesTable">
                         <thead>
                             <tr>
                                 <th data-sort="date">Date</th>
                                 <th data-sort="text">Name</th>
                                 <th data-sort="text">Category</th>
                                 <th data-sort="number">Amount</th>
                                 <th data-sort="text">Type</th>
                                 <th></th>
                             </tr>
                         </thead>
                         <tbody>
                             @if (Model.ViewModel.IrregularExpenses.Any())
                             {
                                 @foreach (var expense in Model.ViewModel.IrregularExpenses)
                                 {
                                     <tr class="fade-in">
                                         <td data-sort-value="@expense.Date.ToString("yyyy-MM-dd")">@expense.Date.ToString("dd/MM/yyyy")</td>
                                         <td>@expense.Name</td>
                                         <td>@(expense.Category?.Name ?? "Uncategorized")</td>
                                         <td data-sort-value="@expense.Amount">@expense.Amount.ToString("C", new System.Globalization.CultureInfo(expense.Currency.ToCultureCode()))</td>
                                         <td>
                                             <span class="badge bg-@(expense.ExpenseType == ExpenseType.Family ? "primary" : "secondary")">
                                                 @if (expense.ExpenseType == ExpenseType.Family)
                                                 {
                                                     <text>Family</text>
                                                 }
                                                 else
                                                 {
                                                     @($"Individual: {expense.FamilyMember?.Name ?? "Unknown"}")
                                                 }
                                             </span>
                                         </td>
                                         <td>
                                             <div class="d-flex flex-wrap align-items-center gap-2">
                                                 <button type="button" class="btn btn-sm btn-secondary" onclick="editIrregularExpense(@expense.Id)" title="Edit" aria-label="Edit">
                                                     <i class="bi bi-pencil"></i>
                                                 </button>
                                                 <form method="post" asp-page-handler="DeleteIrregularExpense" asp-route-expenseId="@expense.Id" class="d-inline" data-confirm="Delete this one-time expense? This action cannot be undone." data-loading="Deleting expense...">
                                                     <input type="hidden" name="SelectedDate" value="@Model.ViewModel.SelectedDate.ToString("yyyy-MM-dd")" />
                                                     <button type="submit" class="btn btn-sm btn-danger align-middle" title="Delete" aria-label="Delete">
                                                         <i class="bi bi-trash"></i>
                                                     </button>
                                                 </form>
                                             </div>
                                         </td>
                                     </tr>
                                 }
                             }
                             else
                             {
                                 <tr>
                                     <td colspan="6" class="text-center text-muted">No one-time expenses found. <a href="#" data-bs-toggle="modal" data-bs-target="#addIrregularExpenseModal">Add your first expense</a></td>
                                 </tr>
                             }
                         </tbody>
                     </table>
                     </div>
                 </div>
             </div>
         </div>
     </div>
</div>

<!-- Add Regular Expense Modal -->
<div class="modal fade" id="addRegularExpenseModal" tabindex="-1" aria-labelledby="addRegularExpenseModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="addRegularExpenseModalLabel">Add Regular Expense</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <form method="post" asp-page-handler="AddRegularExpense" data-loading="Adding expense...">
                    <input type="hidden" name="SelectedDate" value="@Model.ViewModel.SelectedDate.ToString("yyyy-MM-dd")" />
                    <div class="mb-3">
                        <label for="regularExpenseName" class="form-label">Name</label>
                        <input type="text" id="regularExpenseName" name="name" class="form-control" required />
                    </div>
                    <div class="mb-3">
                        <label for="regularExpenseAmount" class="form-label">Amount</label>
                        <input type="number" id="regularExpenseAmount" name="amount" step="0.01" class="form-control" required />
                    </div>
                    <div class="mb-3">
                        <label for="regularExpenseCategory" class="form-label">Category</label>
                        <select id="regularExpenseCategory" name="categoryId" class="form-control" required>
                            <option value="">Select Category</option>
                            @foreach (var category in allExpenseCategories)
                            {
                                <option value="@category.Id">@category.Name</option>
                            }
                        </select>
                    </div>
                    <div class="mb-3">
                        <label for="regularExpenseType" class="form-label">Expense Type</label>
                        <select id="regularExpenseType" name="expenseType" class="form-control" required onchange="toggleFamilyMemberSelection('regularExpense')">
                            <option value="Family" selected>Family</option>
                            <option value="Individual">Individual</option>
                        </select>
                    </div>
                    <div class="mb-3" id="regularExpenseFamilyMemberContainer" style="display: none;">
                        <label for="regularExpenseFamilyMember" class="form-label">Family Member</label>
                        <select id="regularExpenseFamilyMember" name="familyMemberId" class="form-control">
                            <option value="">Select Family Member</option>
                            @foreach (var member in await Model.GetFamilyMembersAsync())
                            {
                                <option value="@member.Id">@member.Name (@member.Relationship)</option>
                            }
                        </select>
                    </div>
                    <div class="mb-3">
                        <label for="regularExpenseCurrency" class="form-label">Currency</label>
                        <select id="regularExpenseCurrency" name="currency" class="form-control" required>
                            <option value="CZK" selected>CZK</option>
                            <option value="EUR">EUR</option>
                            <option value="USD">USD</option>
                        </select>
                    </div>
                    <div class="mb-3">
                        <label for="regularExpenseFrequency" class="form-label">Frequency</label>
                        <select id="regularExpenseFrequency" name="frequency" class="form-control" required>
                            <option value="Monthly">Monthly</option>
                            <option value="Quarterly">Quarterly</option>
                            <option value="SemiAnnually">Semi-Annually</option>
                            <option value="Annually">Annually</option>
                        </select>
                    </div>
                    <div class="mb-3">
                        <label class="form-label">Start Date</label>
                        <div class="row g-2">
                            <div class="col-4">
                                <select id="regularExpenseStartYear" name="startYear" class="form-control" required>
                                    <option value="">Year</option>
                                    @for (int y = DateTime.Today.Year - 1; y <= DateTime.Today.Year + 5; y++)
                                    {
                                        <option value="@y" selected="@(y == DateTime.Today.Year)">@y</option>
                                    }
                                </select>
                            </div>
                            <div class="col-4">
                                <select id="regularExpenseStartMonth" name="startMonth" class="form-control" required>
                                    <option value="">Month</option>
                                    @for (int m = 1; m <= 12; m++)
                                    {
                                        <option value="@m" selected="@(m == DateTime.Today.Month)">@System.Globalization.CultureInfo.CurrentCulture.DateTimeFormat.GetMonthName(m)</option>
                                    }
                                </select>
                            </div>
                            <div class="col-4">
                                <input type="number" id="regularExpenseStartDay" name="startDay" min="1" max="31" value="1" class="form-control" required />
                            </div>
                        </div>
                        <div class="form-text">Select the year, month, and day when this recurring expense should start.</div>
                    </div>
                    <button type="submit" class="btn btn-primary" title="Add Expense" aria-label="Add Expense">
                        <i class="bi bi-plus-lg"></i>
                        <span class="d-none d-sm-inline ms-2">Add Expense</span>
                    </button>
                </form>
            </div>
        </div>
    </div>
</div>

<!-- Add One-Time Expense Modal -->
<div class="modal fade" id="addIrregularExpenseModal" tabindex="-1" aria-labelledby="addIrregularExpenseModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="addIrregularExpenseModalLabel">Add One-Time Expense</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <form method="post" asp-page-handler="AddIrregularExpense" data-loading="Adding expense...">
                    <input type="hidden" name="SelectedDate" value="@Model.ViewModel.SelectedDate.ToString("yyyy-MM-dd")" />
                    <div class="mb-3">
                        <label for="irregularExpenseName" class="form-label">Name</label>
                        <input type="text" id="irregularExpenseName" name="name" class="form-control" required />
                    </div>
                    <div class="mb-3">
                        <label for="irregularExpenseAmount" class="form-label">Amount</label>
                        <input type="number" id="irregularExpenseAmount" name="amount" step="0.01" class="form-control" required />
                    </div>
                    <div class="mb-3">
                        <label for="irregularExpenseCategory" class="form-label">Category</label>
                        <select id="irregularExpenseCategory" name="categoryId" class="form-control" required>
                            <option value="">Select Category</option>
                            @foreach (var category in allExpenseCategories)
                            {
                                <option value="@category.Id">@category.Name</option>
                            }
                        </select>
                    </div>
                    <div class="mb-3">
                        <label for="irregularExpenseType" class="form-label">Expense Type</label>
                        <select id="irregularExpenseType" name="expenseType" class="form-control" required onchange="toggleFamilyMemberSelection('irregularExpense')">
                            <option value="Family" selected>Family</option>
                            <option value="Individual">Individual</option>
                        </select>
                    </div>
                    <div class="mb-3" id="irregularExpenseFamilyMemberContainer" style="display: none;">
                        <label for="irregularExpenseFamilyMember" class="form-label">Family Member</label>
                        <select id="irregularExpenseFamilyMember" name="familyMemberId" class="form-control">
                            <option value="">Select Family Member</option>
                            @foreach (var member in await Model.GetFamilyMembersAsync())
                            {
                                <option value="@member.Id">@member.Name (@member.Relationship)</option>
                            }
                        </select>
                    </div>
                    <div class="mb-3">
                        <label for="irregularExpenseCurrency" class="form-label">Currency</label>
                        <select id="irregularExpenseCurrency" name="currency" class="form-control" required>
                            <option value="CZK" selected>CZK</option>
                            <option value="EUR">EUR</option>
                            <option value="USD">USD</option>
                        </select>
                    </div>
                    <div class="mb-3">
                        <label for="irregularExpenseDate" class="form-label">Date</label>
                        <input type="date" id="irregularExpenseDate" name="date" class="form-control" required value="@DateTime.Today.ToString("yyyy-MM-dd")" />
                    </div>
                    <button type="submit" class="btn btn-primary" title="Add Expense" aria-label="Add Expense">
                        <i class="bi bi-plus-lg"></i>
                        <span class="d-none d-sm-inline ms-2">Add Expense</span>
                    </button>
                </form>
            </div>
        </div>
    </div>
</div>

<!-- Edit Regular Expense Modal -->
<div class="modal fade" id="editRegularExpenseModal" tabindex="-1" aria-labelledby="editRegularExpenseModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="editRegularExpenseModalLabel">Edit Regular Expense</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <form method="post" asp-page-handler="UpdateRegularExpense" data-loading="Updating expense...">
                    <input type="hidden" name="SelectedDate" value="@Model.ViewModel.SelectedDate.ToString("yyyy-MM-dd")" />
                    <input type="hidden" id="editExpenseId" name="id" />
                    <div class="mb-3">
                        <label for="editRegularExpenseName" class="form-label">Name</label>
                        <input type="text" id="editRegularExpenseName" name="name" class="form-control" required />
                    </div>
                    <div class="mb-3">
                        <label for="editRegularExpenseAmount" class="form-label">Amount</label>
                        <input type="number" id="editRegularExpenseAmount" name="amount" step="0.01" class="form-control" required />
                    </div>
                    <div class="mb-3">
                        <label for="editRegularExpenseCategory" class="form-label">Category</label>
                        <select id="editRegularExpenseCategory" name="categoryId" class="form-control" required>
                            <option value="">Select Category</option>
                            @foreach (var category in allExpenseCategories)
                            {
                                <option value="@category.Id">@category.Name</option>
                            }
                        </select>
                    </div>
                    <div class="mb-3">
                        <label for="editRegularExpenseType" class="form-label">Expense Type</label>
                        <select id="editRegularExpenseType" name="expenseType" class="form-control" required onchange="toggleFamilyMemberSelection('editRegularExpense')">
                            <option value="Family">Family</option>
                            <option value="Individual">Individual</option>
                        </select>
                    </div>
                    <div class="mb-3" id="editRegularExpenseFamilyMemberContainer" style="display: none;">
                        <label for="editRegularExpenseFamilyMember" class="form-label">Family Member</label>
                        <select id="editRegularExpenseFamilyMember" name="familyMemberId" class="form-control">
                            <option value="">Select Family Member</option>
                            @foreach (var member in await Model.GetFamilyMembersAsync())
                            {
                                <option value="@member.Id">@member.Name (@member.Relationship)</option>
                            }
                        </select>
                    </div>
                    <div class="mb-3">
                        <label for="editRegularExpenseCurrency" class="form-label">Currency</label>
                        <select id="editRegularExpenseCurrency" name="currency" class="form-control" required>
                            <option value="CZK">CZK</option>
                            <option value="EUR">EUR</option>
                            <option value="USD">USD</option>
                        </select>
                    </div>
                    <div class="mb-3">
                        <label for="editRegularExpenseFrequency" class="form-label">Frequency</label>
                        <select id="editRegularExpenseFrequency" name="frequency" class="form-control" required>
                            <option value="Monthly">Monthly</option>
                            <option value="Quarterly">Quarterly</option>
                            <option value="SemiAnnually">Semi-Annually</option>
                            <option value="Annually">Annually</option>
                        </select>
                    </div>
                    <div class="mb-3">
                        <label for="editRegularExpenseStartDate" class="form-label">Start Year and Month</label>
                        <div class="row g-2">
                            <div class="col-6">
                                <select id="editRegularExpenseStartYear" name="startYear" class="form-control" required>
                                    <option value="">Year</option>
                                    @for (int y = DateTime.Today.Year - 1; y <= DateTime.Today.Year + 5; y++)
                                    {
                                        <option value="@y">@y</option>
                                    }
                                </select>
                            </div>
                            <div class="col-6">
                                <select id="editRegularExpenseStartMonth" name="startMonth" class="form-control" required>
                                    <option value="">Month</option>
                                    @for (int m = 1; m <= 12; m++)
                                    {
                                        <option value="@m">@System.Globalization.CultureInfo.CurrentCulture.DateTimeFormat.GetMonthName(m)</option>
                                    }
                                </select>
                            </div>
                        </div>
                    </div>

                    <!-- Schedule History Section -->
                    <div class="mb-3">
                        <label class="form-label">Schedule History</label>
                        <div class="table-responsive">
                            <table class="table table-striped table-sm table-bordered" id="editExpenseSchedulesTable">
                                <thead class="table-light">
                                    <tr>
                                        <th>Start Year/Month</th>
                                        <th>End Year/Month</th>
                                        <th>Amount</th>
                                        <th>Status</th>
                                    </tr>
                                </thead>
                                <tbody id="editExpenseSchedulesBody">
                                    <!-- Schedule rows will be populated by JavaScript -->
                                </tbody>
                            </table>
                        </div>
                        <div class="form-text">
                            <small class="text-muted">This table shows all historical and future schedule changes for this recurring expense.</small>
                        </div>
                    </div>

                    <div class="alert alert-info">
                        <small><strong>Note:</strong> Changes will only apply from the selected start month forward. Historical expense data will remain unchanged.</small>
                    </div>
                    <button type="submit" class="btn btn-primary" title="Update Expense" aria-label="Update Expense">
                        <i class="bi bi-save"></i>
                        <span class="d-none d-sm-inline ms-2">Update Expense</span>
                    </button>
                </form>
            </div>
        </div>
    </div>
</div>

<!-- Edit Irregular Expense Modal -->
<div class="modal fade" id="editIrregularExpenseModal" tabindex="-1" aria-labelledby="editIrregularExpenseModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="editIrregularExpenseModalLabel">Edit Irregular Expense</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <form method="post" asp-page-handler="UpdateIrregularExpense" data-loading="Updating expense...">
                    <input type="hidden" name="SelectedDate" value="@Model.ViewModel.SelectedDate.ToString("yyyy-MM-dd")" />
                    <input type="hidden" id="editIrregularExpenseId" name="id" />
                    <div class="mb-3">
                        <label for="editIrregularExpenseName" class="form-label">Name</label>
                        <input type="text" id="editIrregularExpenseName" name="name" class="form-control" required />
                    </div>
                    <div class="mb-3">
                        <label for="editIrregularExpenseAmount" class="form-label">Amount</label>
                        <input type="number" id="editIrregularExpenseAmount" name="amount" step="0.01" class="form-control" required />
                    </div>
                    <div class="mb-3">
                        <label for="editIrregularExpenseCategory" class="form-label">Category</label>
                        <select id="editIrregularExpenseCategory" name="categoryId" class="form-control" required>
                            <option value="">Select Category</option>
                            @foreach (var category in allExpenseCategories)
                            {
                                <option value="@category.Id">@category.Name</option>
                            }
                        </select>
                    </div>
                    <div class="mb-3">
                        <label for="editIrregularExpenseType" class="form-label">Expense Type</label>
                        <select id="editIrregularExpenseType" name="expenseType" class="form-control" required onchange="toggleFamilyMemberSelection('editIrregularExpense')">
                            <option value="Family">Family</option>
                            <option value="Individual">Individual</option>
                        </select>
                    </div>
                    <div class="mb-3" id="editIrregularExpenseFamilyMemberContainer" style="display: none;">
                        <label for="editIrregularExpenseFamilyMember" class="form-label">Family Member</label>
                        <select id="editIrregularExpenseFamilyMember" name="familyMemberId" class="form-control">
                            <option value="">Select Family Member</option>
                            @foreach (var member in await Model.GetFamilyMembersAsync())
                            {
                                <option value="@member.Id">@member.Name (@member.Relationship)</option>
                            }
                        </select>
                    </div>
                    <div class="mb-3">
                        <label for="editIrregularExpenseCurrency" class="form-label">Currency</label>
                        <select id="editIrregularExpenseCurrency" name="currency" class="form-control" required>
                            <option value="CZK">CZK</option>
                            <option value="EUR">EUR</option>
                            <option value="USD">USD</option>
                        </select>
                    </div>
                    <div class="mb-3">
                        <label for="editIrregularExpenseDate" class="form-label">Date</label>
                        <input type="date" id="editIrregularExpenseDate" name="date" class="form-control" required />
                    </div>
                    <button type="submit" class="btn btn-primary" title="Update Expense" aria-label="Update Expense">
                        <i class="bi bi-save"></i>
                        <span class="d-none d-sm-inline ms-2">Update Expense</span>
                    </button>
                </form>
            </div>
        </div>
    </div>
</div>

<!-- Add One-Time Income Modal -->
<div class="modal fade" id="addOneTimeIncomeModal" tabindex="-1" aria-labelledby="addOneTimeIncomeModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="addOneTimeIncomeModalLabel">Add One-Time Income</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <form method="post" asp-page-handler="AddOneTimeIncome" data-loading="Adding income...">
                    <input type="hidden" name="SelectedDate" value="@Model.ViewModel.SelectedDate.ToString("yyyy-MM-dd")" />
                    <div class="mb-3">
                        <label for="oneTimeIncomeName" class="form-label">Name</label>
                        <input type="text" id="oneTimeIncomeName" name="name" class="form-control" required />
                    </div>
                    <div class="mb-3">
                        <label for="oneTimeIncomeAmount" class="form-label">Amount</label>
                        <input type="number" id="oneTimeIncomeAmount" name="amount" step="0.01" class="form-control" required />
                    </div>
                    <div class="mb-3">
                        <label for="oneTimeIncomeSource" class="form-label">Income Source (Optional)</label>
                        <select id="oneTimeIncomeSource" name="incomeSourceId" class="form-control">
                            <option value="">Select Source (Optional)</option>
                            @foreach (var source in await Model.GetIncomeSourcesAsync())
                            {
                                <option value="@source.Id">@source.Name</option>
                            }
                        </select>
                    </div>
                    <div class="mb-3">
                        <label for="oneTimeIncomeCurrency" class="form-label">Currency</label>
                        <select id="oneTimeIncomeCurrency" name="currency" class="form-control" required>
                            <option value="CZK" selected>CZK</option>
                            <option value="EUR">EUR</option>
                            <option value="USD">USD</option>
                        </select>
                    </div>
                    <div class="mb-3">
                        <label for="oneTimeIncomeDate" class="form-label">Date</label>
                        <input type="date" id="oneTimeIncomeDate" name="date" class="form-control" required value="@DateTime.Today.ToString("yyyy-MM-dd")" />
                    </div>
                    <button type="submit" class="btn btn-primary" title="Add Income" aria-label="Add Income">
                        <i class="bi bi-plus-lg"></i>
                        <span class="d-none d-sm-inline ms-2">Add Income</span>
                    </button>
                </form>
            </div>
        </div>
    </div>
</div>

<!-- Edit One-Time Income Modal -->
<div class="modal fade" id="editOneTimeIncomeModal" tabindex="-1" aria-labelledby="editOneTimeIncomeModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="editOneTimeIncomeModalLabel">Edit One-Time Income</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <form method="post" asp-page-handler="UpdateOneTimeIncome" data-loading="Updating income...">
                    <input type="hidden" name="SelectedDate" value="@Model.ViewModel.SelectedDate.ToString("yyyy-MM-dd")" />
                    <input type="hidden" id="editOneTimeIncomeId" name="id" />
                    <div class="mb-3">
                        <label for="editOneTimeIncomeName" class="form-label">Name</label>
                        <input type="text" id="editOneTimeIncomeName" name="name" class="form-control" required />
                    </div>
                    <div class="mb-3">
                        <label for="editOneTimeIncomeAmount" class="form-label">Amount</label>
                        <input type="number" id="editOneTimeIncomeAmount" name="amount" step="0.01" class="form-control" required />
                    </div>
                    <div class="mb-3">
                        <label for="editOneTimeIncomeSource" class="form-label">Income Source (Optional)</label>
                        <select id="editOneTimeIncomeSource" name="incomeSourceId" class="form-control">
                            <option value="">Select Source (Optional)</option>
                            @foreach (var source in await Model.GetIncomeSourcesAsync())
                            {
                                <option value="@source.Id">@source.Name</option>
                            }
                        </select>
                    </div>
                    <div class="mb-3">
                        <label for="editOneTimeIncomeCurrency" class="form-label">Currency</label>
                        <select id="editOneTimeIncomeCurrency" name="currency" class="form-control" required>
                            <option value="CZK">CZK</option>
                            <option value="EUR">EUR</option>
                            <option value="USD">USD</option>
                        </select>
                    </div>
                    <div class="mb-3">
                        <label for="editOneTimeIncomeDate" class="form-label">Date</label>
                        <input type="date" id="editOneTimeIncomeDate" name="date" class="form-control" required />
                    </div>
                    <button type="submit" class="btn btn-primary" title="Update Income" aria-label="Update Income">
                        <i class="bi bi-save"></i>
                        <span class="d-none d-sm-inline ms-2">Update Income</span>
                    </button>
                </form>
            </div>
        </div>
    </div>
</div>

<!-- Adjust Start Date Modal -->
<div class="modal fade" id="adjustStartDateModal" tabindex="-1" aria-labelledby="adjustStartDateModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="adjustStartDateModalLabel">Adjust Financial Month Start Date</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <form method="post" asp-page-handler="AdjustStartDate" data-loading="Saving...">
                    <input type="hidden" name="SelectedDate" value="@Model.ViewModel.SelectedDate.ToString("yyyy-MM-dd")" />
                    <div class="mb-3">
                        <label for="overrideStartDate" class="form-label">New Start Date for this Financial Month</label>
                        <input type="date" id="overrideStartDate" name="overrideDate" class="form-control" required value="@Model.PrefilledOverrideDate" />
                        <div class="form-text">
                            Select the exact date when this financial month should begin. This will only affect the current period.
                        </div>
                    </div>
                    <button type="submit" class="btn btn-primary">Save</button>
                </form>
            </div>
        </div>
    </div>
</div>

<!-- Import Statement Modal -->
<div class="modal fade" id="importStatementModal" tabindex="-1" aria-labelledby="importStatementModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered modal-xl">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="importStatementModalLabel">Import Bank Statement</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div class="row g-3 mb-3 align-items-end">
                    <div class="col-md-6">
                        <label for="bankProfileSelect" class="form-label">Bank profile</label>
                        <select class="form-select" id="bankProfileSelect">
                            <option value="">Select a bank profile...</option>
                            @foreach (var profile in Model.BankProfiles.OrderBy(p => p.DisplayName))
                            {
                                <option value="@profile.Id" data-default-skip="@profile.DefaultSkipRows">@profile.DisplayName</option>
                            }
                        </select>
                        <div class="form-text" id="bankProfileHint">Pick the bank export format so FinApp can interpret the columns correctly.</div>
                    </div>
                    <div class="col-md-6">
                        <div class="alert alert-info mb-0 py-2 px-3 small" id="bankProfileDescription" role="note">
                            Select a profile to view details and enable statement uploads.
                        </div>
                    </div>
                </div>
                <div class="mb-3">
                    <label for="bankStatementFile" class="form-label">Choose CSV File</label>
                    <input type="file" class="form-control" id="bankStatementFile" accept=".csv,.txt" />
                    <div class="form-text">Select the exported statement (CSV). Contents will be previewed below.</div>
                </div>
                <div class="row g-3 align-items-end mb-3">
                    <div class="col-sm-4">
                        <label for="importSkipRows" class="form-label">Metadata rows to skip</label>
                        <input type="number" class="form-control" id="importSkipRows" min="0" value="0" disabled />
                    </div>
                    <div class="col-sm-8">
                        <div class="form-text d-flex flex-wrap align-items-center gap-2">
                            <span id="importAutoDetectedDesc">Auto-detected 0 metadata rows.</span>
                            <button type="button" class="btn btn-sm btn-outline-secondary" id="importApplyAutoSkip" disabled>
                                Use auto-detected value
                            </button>
                        </div>
                    </div>
                </div>
                <div id="importPreviewStatus" class="alert alert-secondary" role="status">
                    No file selected.
                </div>
                <div class="table-responsive d-none" id="importPreviewTableContainer">
                    <table class="table table-striped table-sm mb-0 text-center" id="importPreviewTable">
                        <thead>
                            <tr id="importPreviewTableHead"></tr>
                        </thead>
                        <tbody id="importPreviewTableBody"></tbody>
                    </table>
                </div>
                @Html.AntiForgeryToken()
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-primary" id="importStatementSubmit" disabled>
                    <span class="default-label">Import Expenses</span>
                </button>
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
            </div>
        </div>
    </div>
</div>

@section Scripts {
    <script>
    window.bankImportProfiles = @Html.Raw(JsonSerializer.Serialize(Model.BankProfilesDetailed, new JsonSerializerOptions { PropertyNamingPolicy = JsonNamingPolicy.CamelCase }));
    window.familyMembers = @Html.Raw(JsonSerializer.Serialize(Model.FamilyMembers ?? Array.Empty<FamilyMember>(), new JsonSerializerOptions { PropertyNamingPolicy = JsonNamingPolicy.CamelCase }));
    window.expenseCategories = @Html.Raw(JsonSerializer.Serialize(allExpenseCategories, new JsonSerializerOptions { PropertyNamingPolicy = JsonNamingPolicy.CamelCase }));
    </script>
    <!-- Native month input provides best mobile experience -->
    <script>
        // Toggle icons for collapsible sections
        document.addEventListener('DOMContentLoaded', function () {
            const pairs = [
                { collapseId: 'regularExpensesCollapse', chevronId: 'regularChevron' },
                { collapseId: 'irregularExpensesCollapse', chevronId: 'irregularChevron' },
                { collapseId: 'regularIncomesCollapse', chevronId: 'regularIncomesChevron' },
                { collapseId: 'oneTimeIncomesCollapse', chevronId: 'oneTimeIncomesChevron' },
                { collapseId: 'budgetsCollapse', chevronId: 'budgetsChevron' }
            ];
            pairs.forEach(({ collapseId, chevronId }) => {
                const collapseEl = document.getElementById(collapseId);
                const chevron = document.getElementById(chevronId);
                if (!collapseEl || !chevron) return;
                collapseEl.addEventListener('hide.bs.collapse', () => {
                    chevron.classList.remove('bi-caret-down-fill');
                    chevron.classList.add('bi-caret-right-fill');
                });
                collapseEl.addEventListener('show.bs.collapse', () => {
                    chevron.classList.remove('bi-caret-right-fill');
                    chevron.classList.add('bi-caret-down-fill');
                });
            });
        });
    </script>
    <script>
        (function () {
            const bankProfiles = Array.isArray(window.bankImportProfiles) ? window.bankImportProfiles : [];
            const familyMembers = Array.isArray(window.familyMembers) ? window.familyMembers : [];
            const rawExpenseCategories = Array.isArray(window.expenseCategories) ? window.expenseCategories : [];
            const activeFamilyMembers = familyMembers.filter(member => member && (member.isActive ?? true));
            const expenseCategoryMapById = new Map();
            const expenseCategoryNameLookup = new Map();

            rawExpenseCategories.forEach(category => {
                if (!category || category.id == null) {
                    return;
                }
                const numericId = Number(category.id);
                if (!Number.isFinite(numericId)) {
                    return;
                }
                const name = (category.name ?? '').toString();
                expenseCategoryMapById.set(numericId, {
                    id: numericId,
                    name
                });
                const normalized = normalizeText(name);
                if (normalized.length && !expenseCategoryNameLookup.has(normalized)) {
                    expenseCategoryNameLookup.set(normalized, numericId);
                }
            });

            const availableExpenseCategories = Array.from(expenseCategoryMapById.values())
                .sort((a, b) => a.name.localeCompare(b.name, undefined, { sensitivity: 'base' }));
            const fileInputId = 'bankStatementFile';
            const profileSelectId = 'bankProfileSelect';
            const profileDescriptionId = 'bankProfileDescription';
            const statusId = 'importPreviewStatus';
            const containerId = 'importPreviewTableContainer';
            const headId = 'importPreviewTableHead';
            const bodyId = 'importPreviewTableBody';
            const modalId = 'importStatementModal';
            const skipInputId = 'importSkipRows';
            const autoDescId = 'importAutoDetectedDesc';
            const autoButtonId = 'importApplyAutoSkip';
            const submitButtonId = 'importStatementSubmit';
            const selectAllCheckboxId = 'importSelectAllRows';

            const fieldLabels = {
                transactionDate: 'Transaction Date',
                bookingDate: 'Booking Date',
                amount: 'Amount',
                currency: 'Currency',
                direction: 'Direction',
                counterparty: 'Counterparty',
                counterpartyAccount: 'Counterparty Account',
                counterpartyAccountName: 'Counterparty Account Name',
                memo: 'Personal Note',
                recipientMessage: 'Message to Recipient',
                bankNote: 'Bank Note',
                bankCategory: 'Bank Category',
                transactionType: 'Transaction Type',
                originalAmount: 'Original Amount',
                originalCurrency: 'Original Currency',
                exchangeRate: 'Exchange Rate',
                merchantLocation: 'Merchant Location',
                cardName: 'Card Name',
                cardNumber: 'Card Number',
                cardHolder: 'Card Holder',
                reference: 'Reference',
                vs: 'Variable Symbol',
                ks: 'Constant Symbol',
                ss: 'Specific Symbol'
            };

            const expenseFieldLabels = {
                name: 'Expense Name',
                amount: 'Amount',
                currency: 'Currency',
                date: 'Date',
                expenseType: 'Expense Type',
                memo: 'Memo',
                categoryId: 'Category',
                familyMemberId: 'Family Member'
            };

            const requiredExpenseFields = new Set(['name', 'amount', 'currency', 'date', 'categoryId']);
            let rowSelectionState = new Map();
            let rowSelectionControlMap = new Map();

            const EXPENSE_TYPE_FAMILY_VALUE = 'family';
            const EXPENSE_TYPE_MEMBER_PREFIX = 'member:';

            let currentFileName = null;
            let pendingFile = null;
            let parsedRows = [];
            let autoSkipRows = 0;
            let currentSkipRows = 0;
            let requestedSkipRows = 0;
            let activeProfile = null;
            let activeProfileColumns = [];
            let activeProfileMappings = [];
            let latestHeaderRow = [];
            let latestDataRows = [];
            let resolvedTargetMap = new Map();
            let resolvedHeaderMap = new Map();
            let previewFields = [];
            let missingRequiredFields = [];
            let previewRowData = [];
            let expenseTypeControlMap = new Map();
            const expenseTypeSelectionMap = new Map();
            let previewStatusContext = null;

            const LOG_PREFIX = '[StatementImport]';

            function logEvent(level, message, details) {
                try {
                    const logger = console?.[level] ?? console?.log;
                    if (typeof logger !== 'function') {
                        return;
                    }
                    if (details !== undefined) {
                        logger(`${LOG_PREFIX} ${message}`, details);
                    } else {
                        logger(`${LOG_PREFIX} ${message}`);
                    }
                } catch (err) {
                    // Swallow logging failures to avoid breaking UI
                }
            }

            const statusEl = () => document.getElementById(statusId);
            const containerEl = () => document.getElementById(containerId);
            const headEl = () => document.getElementById(headId);
            const bodyEl = () => document.getElementById(bodyId);
            const skipInputEl = () => document.getElementById(skipInputId);
            const autoDescEl = () => document.getElementById(autoDescId);
            const autoButtonEl = () => document.getElementById(autoButtonId);
            const submitButtonEl = () => document.getElementById(submitButtonId);
            const fileInputEl = () => document.getElementById(fileInputId);
            const profileSelectEl = () => document.getElementById(profileSelectId);
            const profileDescriptionEl = () => document.getElementById(profileDescriptionId);
            const selectAllCheckboxEl = () => document.getElementById(selectAllCheckboxId);

            const getParserSettings = () => activeProfile?.parser ?? {};
            const getProfileDisplayName = () => activeProfile?.metadata?.displayName ?? activeProfile?.id ?? 'Profile';
            const getProfileDescription = () => activeProfile?.metadata?.description ?? '';
            const getProfileSample = () => activeProfile?.metadata?.sampleFile ?? '';

            function normalizeText(value) {
                return (value ?? '')
                    .toString()
                    .trim()
                    .toLowerCase()
                    .normalize('NFD')
                    .replace(/[\x00-\x1F]/g, '')
                    .replace(/[\u0300-\u036f]/g, '')
                    .replace(/\s+/g, ' ');
            }

            function normalizeHeader(value) {
                return normalizeText(value);
            }

            function getFamilyMemberById(id) {
                if (id == null) {
                    return null;
                }
                return activeFamilyMembers.find(member => Number(member.id) === Number(id)) ?? null;
            }

            function getExpenseCategoryById(id) {
                if (id == null) {
                    return null;
                }
                const numericId = Number(id);
                if (!Number.isFinite(numericId)) {
                    return null;
                }
                return expenseCategoryMapById.get(numericId) ?? null;
            }

            function resolveCategoryId(candidate) {
                if (candidate == null) {
                    return null;
                }

                if (typeof candidate === 'number' && Number.isFinite(candidate)) {
                    return expenseCategoryMapById.has(candidate) ? candidate : null;
                }

                const text = candidate.toString().trim();
                if (!text.length) {
                    return null;
                }

                const numeric = Number.parseInt(text, 10);
                if (!Number.isNaN(numeric) && expenseCategoryMapById.has(numeric)) {
                    return numeric;
                }

                const normalized = normalizeText(text);
                if (normalized.length && expenseCategoryNameLookup.has(normalized)) {
                    return expenseCategoryNameLookup.get(normalized) ?? null;
                }

                return null;
            }

            function deriveExpenseTypeSelection(displayValue, rowPayload, valueResult) {
                if (rowPayload && rowPayload.familyMemberId != null) {
                    const member = getFamilyMemberById(rowPayload.familyMemberId);
                    if (member) {
                        return { expenseType: 'Individual', familyMemberId: member.id };
                    }
                }

                if (valueResult && valueResult.rawValue != null) {
                    const rawNumeric = Number.parseInt(valueResult.rawValue, 10);
                    if (!Number.isNaN(rawNumeric)) {
                        const member = getFamilyMemberById(rawNumeric);
                        if (member) {
                            return { expenseType: 'Individual', familyMemberId: member.id };
                        }
                    }
                }

                const candidateText = valueResult?.displayValue ?? displayValue;
                if (typeof candidateText === 'string') {
                    const normalized = candidateText.trim().toLowerCase();
                    if (normalized === 'family' || normalized === 'shared') {
                        return { expenseType: 'Family', familyMemberId: null };
                    }

                    const matchedMember = activeFamilyMembers.find(member => typeof member.name === 'string' && member.name.trim().toLowerCase() === normalized);
                    if (matchedMember) {
                        return { expenseType: 'Individual', familyMemberId: matchedMember.id };
                    }
                }

                return { expenseType: 'Family', familyMemberId: null };
            }

            function encodeExpenseTypeSelection(selection) {
                if (!selection || selection.expenseType !== 'Individual' || selection.familyMemberId == null) {
                    return EXPENSE_TYPE_FAMILY_VALUE;
                }

                return `${EXPENSE_TYPE_MEMBER_PREFIX}${selection.familyMemberId}`;
            }

            function decodeExpenseTypeSelection(value) {
                if (typeof value === 'string' && value.startsWith(EXPENSE_TYPE_MEMBER_PREFIX)) {
                    const numericId = Number(value.slice(EXPENSE_TYPE_MEMBER_PREFIX.length));
                    if (!Number.isNaN(numericId) && getFamilyMemberById(numericId)) {
                        return { expenseType: 'Individual', familyMemberId: numericId };
                    }
                }

                return { expenseType: 'Family', familyMemberId: null };
            }

            function ensureExpenseTypeSelection(rowIndex, displayValue, rowPayload, valueResult) {
                if (!expenseTypeSelectionMap.has(rowIndex)) {
                    expenseTypeSelectionMap.set(rowIndex, deriveExpenseTypeSelection(displayValue, rowPayload, valueResult));
                }

                return expenseTypeSelectionMap.get(rowIndex);
            }

            function buildExpenseTypeSelect(rowIndex, selection) {
                const select = document.createElement('select');
                select.className = 'form-select form-select-sm';
                select.ariaLabel = 'Expense type';

                const familyOption = document.createElement('option');
                familyOption.value = EXPENSE_TYPE_FAMILY_VALUE;
                familyOption.textContent = 'Family';
                select.appendChild(familyOption);

                activeFamilyMembers.forEach(member => {
                    if (!member || member.id == null) {
                        return;
                    }
                    const option = document.createElement('option');
                    option.value = `${EXPENSE_TYPE_MEMBER_PREFIX}${member.id}`;
                    option.textContent = member.name ?? `Member ${member.id}`;
                    select.appendChild(option);
                });

                select.value = encodeExpenseTypeSelection(selection);

                select.addEventListener('change', event => {
                    const newSelection = decodeExpenseTypeSelection(event.target.value);
                    expenseTypeSelectionMap.set(rowIndex, newSelection);
                    const rowPayload = previewRowData[rowIndex];
                    if (rowPayload) {
                        rowPayload.expenseType = newSelection.expenseType;
                        rowPayload.familyMemberId = newSelection.expenseType === 'Individual' ? newSelection.familyMemberId : null;
                    }
                });

                return select;
            }

            function getTargetLabel(target) {
                if (!target) return '';
                if (fieldLabels[target]) {
                    return fieldLabels[target];
                }
                return target
                    .replace(/([a-z])([A-Z])/g, '$1 $2')
                    .replace(/_/g, ' ')
                    .replace(/^./, c => c.toUpperCase());
            }

            function setStatus(message, type = 'secondary') {
                const status = statusEl();
                if (!status) return;
                status.className = `alert alert-${type}`;
                status.setAttribute('tabindex', '-1');
                status.textContent = message;
            }

            function updateImportButtonState(canImport, rowCount = 0) {
                const button = submitButtonEl();
                if (!button) {
                    return;
                }

                const labelEl = button.querySelector('.default-label');
                const labelTarget = labelEl ?? button;
                if (canImport && rowCount > 0) {
                    labelTarget.textContent = `Import ${rowCount} expense${rowCount === 1 ? '' : 's'}`;
                } else {
                    labelTarget.textContent = 'Import Expenses';
                }

                button.disabled = !canImport;
            }

            function getSelectedRowCount() {
                let count = 0;
                rowSelectionState.forEach((isSelected, rowIndex) => {
                    if (!isSelected) {
                        return;
                    }
                    const payload = previewRowData[rowIndex];
                    if (payload && payload.isValid) {
                        count += 1;
                    }
                });
                return count;
            }

            function updateSelectAllCheckbox() {
                const selectAll = document.getElementById(selectAllCheckboxId);
                if (!selectAll) {
                    return;
                }

                const validRowIndices = [];
                rowSelectionState.forEach((_, rowIndex) => {
                    const payload = previewRowData[rowIndex];
                    if (payload && payload.isValid) {
                        validRowIndices.push(rowIndex);
                    }
                });

                if (!validRowIndices.length) {
                    selectAll.checked = false;
                    selectAll.indeterminate = false;
                    selectAll.disabled = true;
                    return;
                }

                selectAll.disabled = false;
                let selectedCount = 0;
                validRowIndices.forEach(index => {
                    if (rowSelectionState.get(index)) {
                        selectedCount += 1;
                    }
                });

                if (selectedCount === 0) {
                    selectAll.checked = false;
                    selectAll.indeterminate = false;
                } else if (selectedCount === validRowIndices.length) {
                    selectAll.checked = true;
                    selectAll.indeterminate = false;
                } else {
                    selectAll.checked = false;
                    selectAll.indeterminate = true;
                }
            }

            function refreshSelectionState() {
                updateSelectAllCheckbox();
                const selectedCount = getSelectedRowCount();
                updateImportButtonState(selectedCount > 0, selectedCount);
                recomputeStatusSummary();
            }

            function setRowSelection(rowIndex, isSelected, { dueToInvalid = false } = {}) {
                const payload = previewRowData[rowIndex];
                if (!payload || !payload.isValid) {
                    rowSelectionState.set(rowIndex, false);
                    const control = rowSelectionControlMap.get(rowIndex);
                    if (control) {
                        control.checked = false;
                    }
                    return;
                }

                rowSelectionState.set(rowIndex, isSelected);
                const control = rowSelectionControlMap.get(rowIndex);
                if (control) {
                    control.checked = isSelected;
                }

                if (payload) {
                    if (isSelected) {
                        payload.wasDeselectedDueToInvalid = false;
                    }
                }
            }

            function handleSelectAllToggle(shouldSelect) {
                let anyChanged = false;
                previewRowData.forEach((payload, rowIndex) => {
                    if (!payload || !payload.isValid) {
                        return;
                    }

                    const existing = rowSelectionState.get(rowIndex) ?? false;
                    if (existing !== shouldSelect) {
                        anyChanged = true;
                    }
                    setRowSelection(rowIndex, shouldSelect);
                });

                if (anyChanged) {
                    refreshSelectionState();
                } else {
                    updateSelectAllCheckbox();
                }
            }

            function updateRowValidityFromFieldChange(rowIndex) {
                const payload = previewRowData[rowIndex];
                if (!payload) {
                    return;
                }

                const missingSet = payload.missingRequiredFields ?? new Set();
                const isValid = missingSet.size === 0;
                const wasValid = Boolean(payload.isValid);
                const wasSelectedBefore = rowSelectionState.has(rowIndex)
                    ? Boolean(rowSelectionState.get(rowIndex))
                    : true;
                const wasAutoDeselected = Boolean(payload.wasDeselectedDueToInvalid);
                const checkbox = rowSelectionControlMap.get(rowIndex);

                payload.isValid = isValid;

                if (!isValid) {
                    if (checkbox) {
                        checkbox.checked = false;
                        checkbox.disabled = true;
                        checkbox.title = 'Resolve required fields to import this row.';
                    }
                    setRowSelection(rowIndex, false, { dueToInvalid: true });
                    payload.wasDeselectedDueToInvalid = wasSelectedBefore;
                } else {
                    if (checkbox) {
                        checkbox.disabled = false;
                        checkbox.title = '';
                    }
                    if (!wasValid && wasAutoDeselected) {
                        setRowSelection(rowIndex, true);
                    }
                    payload.wasDeselectedDueToInvalid = false;
                }

                refreshSelectionState();
            }

            function recomputeStatusSummary() {
                if (!previewStatusContext) {
                    return;
                }

                const context = previewStatusContext;
                const totalRows = previewRowData.length;
                let validRowCount = 0;
                const missingLabels = new Set();

                previewRowData.forEach(payload => {
                    if (!payload) {
                        return;
                    }

                    if (payload.isValid) {
                        validRowCount += 1;
                    }

                    if (payload.missingRequiredFields instanceof Set) {
                        payload.missingRequiredFields.forEach(label => {
                            if (typeof label === 'string' && label.trim().length) {
                                missingLabels.add(label.trim());
                            }
                        });
                    }
                });

                const selectedCount = getSelectedRowCount();
                const statusParts = [];
                const profileName = context.profileName ?? getProfileDisplayName();
                const fileName = context.fileName ?? currentFileName ?? 'Statement';
                const requested = Number.isFinite(context.requestedSkipRows) ? context.requestedSkipRows : currentSkipRows;
                const applied = Number.isFinite(context.appliedSkipRows) ? context.appliedSkipRows : currentSkipRows;
                const displayRows = Number.isFinite(context.totalRows) ? context.totalRows : totalRows;

                statusParts.push(`${profileName} profile`);
                statusParts.push(`${fileName} loaded.`);

                if (requested !== applied) {
                    statusParts.push(`Requested ${requested} metadata row${requested === 1 ? '' : 's'}, using ${applied} after trimming.`);
                } else {
                    statusParts.push(`Skipped ${applied} metadata row${applied === 1 ? '' : 's'}.`);
                }

                statusParts.push(`Showing ${displayRows} transaction row${displayRows === 1 ? '' : 's'}.`);

                let statusType = 'success';

                if (missingLabels.size) {
                    statusParts.push(`Missing required fields: ${Array.from(missingLabels).join(', ')}.`);
                    statusType = 'warning';
                }

                if (!validRowCount) {
                    statusParts.push('No rows are currently ready to import.');
                    statusType = 'warning';
                }

                if (validRowCount) {
                    statusParts.push(`${selectedCount} of ${validRowCount} valid row${validRowCount === 1 ? '' : 's'} selected for import.`);
                    if (selectedCount === 0) {
                        statusParts.push('Select at least one row to enable import.');
                        statusType = 'warning';
                    }
                }

                setStatus(statusParts.join(' '), statusType);
            }

            function disableSkipControls(message) {
                const skipInput = skipInputEl();
                const autoButton = autoButtonEl();
                if (skipInput) {
                    skipInput.disabled = true;
                }
                if (autoButton) {
                    autoButton.disabled = true;
                }
                const desc = autoDescEl();
                if (desc) {
                    desc.textContent = message ?? (activeProfile
                        ? 'Metadata skip controls will unlock once the statement is loaded.'
                        : 'Select a bank profile to configure metadata skipping.');
                }
            }

            function enableSkipControls() {
                const skipInput = skipInputEl();
                const autoButton = autoButtonEl();
                if (skipInput) {
                    skipInput.disabled = false;
                }
                if (autoButton) {
                    autoButton.disabled = false;
                }
                updateSkipDescription();
            }

            function clearPreviewTable() {
                const container = containerEl();
                const head = headEl();
                const body = bodyEl();
                if (container) {
                    container.classList.add('d-none');
                }
                if (head) {
                    head.replaceChildren();
                }
                if (body) {
                    body.replaceChildren();
                }
                previewStatusContext = null;
            }

            function resetPreview(message, { clearFile = true } = {}) {
                logEvent('debug', `Reset preview (clearFile=${clearFile}) triggered${message ? `: ${message}` : ''}`);
                currentFileName = null;
                parsedRows = [];
                autoSkipRows = 0;
                previewFields = [];
                missingRequiredFields = [];
                latestHeaderRow = [];
                latestDataRows = [];
                resolvedTargetMap = new Map();
                resolvedHeaderMap = new Map();
                previewRowData = [];
                expenseTypeControlMap = new Map();
                expenseTypeSelectionMap.clear();
                rowSelectionState = new Map();
                rowSelectionControlMap = new Map();
                previewStatusContext = null;
                updateImportButtonState(false);

                const parser = getParserSettings();
                currentSkipRows = activeProfile ? Number(parser.defaultSkipRows ?? 0) : 0;
                requestedSkipRows = currentSkipRows;

                const defaultMessage = message
                    ?? (activeProfile ? 'Select a statement file to preview.' : 'Choose a bank profile to begin.');
                const statusType = activeProfile ? 'secondary' : 'info';
                setStatus(defaultMessage, statusType);

                disableSkipControls();
                clearPreviewTable();

                if (clearFile) {
                    pendingFile = null;
                }

                const input = fileInputEl();
                if (input && clearFile) {
                    input.value = '';
                }

                const skipInput = skipInputEl();
                if (skipInput) {
                    skipInput.value = String(currentSkipRows);
                }
            }

            function showError(message) {
                logEvent('error', message);
                setStatus(message, 'danger');
                clearPreviewTable();
            }

            function showLoading(filename) {
                logEvent('info', `Reading file '${filename}' with profile '${getProfileDisplayName()}'`);
                const status = statusEl();
                if (status) {
                    status.className = 'alert alert-info';
                    status.setAttribute('tabindex', '-1');
                    status.innerHTML = `<span class="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true"></span>Reading ${filename}...`;
                }
            }

            function updateProfileDescription() {
                const description = profileDescriptionEl();
                if (!description) {
                    return;
                }

                if (!activeProfile) {
                    logEvent('debug', 'No active profile selected. Description reset.');
                    description.className = 'alert alert-info mb-0 py-2 px-3 small';
                    description.textContent = 'Select a profile to view details and enable statement uploads.';
                    return;
                }

                const parser = getParserSettings();
                const details = [];
                const profileDescription = getProfileDescription();
                if (profileDescription) {
                    details.push(profileDescription);
                }
                details.push(`Default skip rows: ${parser.defaultSkipRows ?? 0}`);
                details.push(`Delimiter: '${parser.delimiter ?? ';'}'`);
                if (parser.encoding) {
                    details.push(`Encoding: ${parser.encoding}`);
                }
                const sample = getProfileSample();
                if (sample) {
                    details.push(`Sample: ${sample}`);
                }

                description.className = 'alert alert-success mb-0 py-2 px-3 small';
                description.textContent = `${getProfileDisplayName()}: ${details.join(' â€¢ ')}`;
            }

            function updateSkipDescription() {
                const desc = autoDescEl();
                if (!desc) return;

                if (!activeProfile) {
                    desc.textContent = 'Select a bank profile to configure metadata skipping.';
                    return;
                }

                const parser = getParserSettings();
                const pieces = [`Profile default skip: ${parser.defaultSkipRows ?? 0}`];
                if (parsedRows.length) {
                    pieces.push(`Auto-detected header near row ${autoSkipRows + 1}`);
                }
                desc.textContent = `${pieces.join('. ')}.`;
            }

            function rowHasContent(row) {
                return row.some(cell => (cell ?? '').trim().length > 0);
            }

            function isLikelyHeaderRow(row) {
                const populated = row.filter(cell => (cell ?? '').trim().length > 0);
                if (populated.length < 3) {
                    return false;
                }

                const candidateText = populated.join(' ');
                const normalized = normalizeText(candidateText);
                const headerKeywords = ['datum', 'date', 'amount', 'castka', 'transaction', 'typ', 'mena'];
                const keywordMatch = headerKeywords.some(keyword => normalized.includes(keyword));

                const fieldThreshold = Math.max(5, populated.length);
                return keywordMatch || row.length >= fieldThreshold;
            }

            function determineAutoSkip(rows) {
                for (let i = 0; i < rows.length; i++) {
                    if (isLikelyHeaderRow(rows[i])) {
                        logEvent('debug', `Auto-detected potential header at zero-based index ${i}`);
                        return i;
                    }
                }
                return 0;
            }

            function getExpenseFieldLabel(field) {
                if (!field) {
                    return 'Value';
                }
                if (expenseFieldLabels[field]) {
                    return expenseFieldLabels[field];
                }
                return field
                    .replace(/([a-z])([A-Z])/g, '$1 $2')
                    .replace(/_/g, ' ')
                    .replace(/^./, c => c.toUpperCase());
            }

            function isMappingRequired(mapping) {
                if (!mapping) {
                    return false;
                }
                if (!requiredExpenseFields.has(mapping.field)) {
                    return false;
                }
                const fallbackValue = typeof mapping.fallback === 'string' ? mapping.fallback.trim() : '';
                return fallbackValue.length === 0;
            }

            function buildColumnResolution(headerRow) {
                const headerMap = new Map();
                headerRow.forEach((value, idx) => {
                    const key = normalizeHeader(value);
                    if (!headerMap.has(key) && key.length) {
                        headerMap.set(key, { index: idx, raw: value });
                    }
                });

                const profileColumns = Array.isArray(activeProfileColumns) ? activeProfileColumns : [];
                const targetInfoMap = new Map();
                const headerInfoMap = new Map();

                profileColumns.forEach(column => {
                    if (!column || !column.target || targetInfoMap.has(column.target)) {
                        return;
                    }

                    const normalizedHeader = normalizeHeader(column.header);
                    let columnIndex = -1;
                    let originalHeader = '';

                    if (headerMap.has(normalizedHeader)) {
                        const match = headerMap.get(normalizedHeader);
                        columnIndex = match.index;
                        originalHeader = match.raw ?? column.header ?? '';
                    } else {
                        const fallbackIndex = headerRow.findIndex(cell => normalizeHeader(cell) === normalizedHeader);
                        if (fallbackIndex >= 0) {
                            columnIndex = fallbackIndex;
                            originalHeader = headerRow[fallbackIndex] ?? column.header ?? '';
                        }
                    }

                    const info = {
                        index: columnIndex,
                        column,
                        header: column.header ?? '',
                        originalHeader
                    };

                    targetInfoMap.set(column.target, info);
                    const normalizedProfileHeader = normalizeHeader(column.header ?? '');
                    if (normalizedProfileHeader.length && !headerInfoMap.has(normalizedProfileHeader)) {
                        headerInfoMap.set(normalizedProfileHeader, info);
                    }
                });

                const mappingTargets = activeProfileMappings
                    .filter(mapping => mapping?.target)
                    .map(mapping => mapping.target);

                const requiredTargets = activeProfileMappings
                    .filter(mapping => mapping?.target && isMappingRequired(mapping))
                    .map(mapping => mapping.target);

                const matchedTargets = mappingTargets.reduce((count, target) => {
                    const info = targetInfoMap.get(target);
                    return info && info.index !== -1 ? count + 1 : count;
                }, 0);

                const matchedRequired = requiredTargets.reduce((count, target) => {
                    const info = targetInfoMap.get(target);
                    return info && info.index !== -1 ? count + 1 : count;
                }, 0);

                return {
                    targetInfoMap,
                    headerInfoMap,
                    matchedTargets,
                    matchedRequired
                };
            }

            function findBestHeaderIndex(startIndex) {
                const lookaheadLimit = 5;
                const mappingsWithTargets = activeProfileMappings.filter(mapping => mapping?.target);
                const requiredCount = mappingsWithTargets.filter(mapping => isMappingRequired(mapping)).length;

                let best = null;

                for (let offset = 0; offset <= lookaheadLimit; offset++) {
                    const candidateIndex = startIndex + offset;
                    if (candidateIndex >= parsedRows.length) {
                        break;
                    }

                    const candidateRow = parsedRows[candidateIndex];
                    if (!rowHasContent(candidateRow)) {
                        continue;
                    }

                    const resolution = buildColumnResolution(candidateRow);

                    logEvent('debug', 'Evaluated header candidate', {
                        candidateIndex,
                        matchedRequired: resolution.matchedRequired,
                        matchedTargets: resolution.matchedTargets,
                        requiredCount
                    });

                    if (!best
                        || resolution.matchedRequired > best.resolution.matchedRequired
                        || (resolution.matchedRequired === best.resolution.matchedRequired && resolution.matchedTargets > best.resolution.matchedTargets)) {
                        best = {
                            index: candidateIndex,
                            resolution
                        };
                    }

                    if (requiredCount > 0 && resolution.matchedRequired === requiredCount) {
                        if (resolution.matchedTargets === mappingsWithTargets.length) {
                            break;
                        }
                    }
                }

                if (best) {
                    logEvent('info', `Selected header row at zero-based index ${best.index}`, {
                        matchedRequired: best.resolution.matchedRequired,
                        matchedTargets: best.resolution.matchedTargets
                    });
                    return best;
                }

                const fallbackRow = parsedRows[startIndex] ?? [];
                logEvent('warn', `Falling back to initial header index ${startIndex}; no strong candidate found.`);
                return {
                    index: startIndex,
                    resolution: buildColumnResolution(fallbackRow)
                };
            }

            function computePreviewModel() {
                previewFields = [];
                missingRequiredFields = [];
                latestHeaderRow = [];
                latestDataRows = [];
                resolvedColumnMap = new Map();

                if (!parsedRows.length) {
                    return { success: false, reason: 'No data available. Upload a CSV to preview.' };
                }

                if (!activeProfileMappings.length) {
                    logEvent('warn', 'Active profile does not define any expense field mappings.');
                    return { success: false, reason: 'No expense field mappings defined for this profile.' };
                }

                if (currentSkipRows >= parsedRows.length) {
                    logEvent('warn', `Current skip rows (${currentSkipRows}) exceeded parsed row count (${parsedRows.length}).`);
                    return { success: false, reason: 'Skipped all rows. Reduce the metadata rows to skip.' };
                }

                let headerIndex = currentSkipRows;
                while (headerIndex < parsedRows.length && !rowHasContent(parsedRows[headerIndex])) {
                    headerIndex += 1;
                }

                if (headerIndex >= parsedRows.length) {
                    return { success: false, reason: 'No header row found. Adjust the metadata rows to skip.' };
                }

                const headerSearch = findBestHeaderIndex(headerIndex);
                headerIndex = headerSearch.index;
                latestHeaderRow = parsedRows[headerIndex];
                latestDataRows = parsedRows.slice(headerIndex + 1).filter(rowHasContent);

                if (!latestDataRows.length) {
                    logEvent('warn', 'Header detected but no data rows found after the header index.');
                    return { success: false, reason: 'Header detected but no transactions found. Adjust metadata rows to skip if needed.' };
                }

                resolvedTargetMap = headerSearch.resolution.targetInfoMap;
                resolvedHeaderMap = headerSearch.resolution.headerInfoMap ?? new Map();

                const prioritizedFields = [];
                const regularFields = [];

                activeProfileMappings.forEach(mapping => {
                    const label = getExpenseFieldLabel(mapping.field);
                    const fallbackValue = typeof mapping.fallback === 'string' ? mapping.fallback.trim() : null;
                    const required = requiredExpenseFields.has(mapping.field);

                    const declaredHeadersRaw = Array.isArray(mapping.sourceHeaders)
                        ? mapping.sourceHeaders
                        : (mapping.sourceHeader ? [mapping.sourceHeader] : []);

                    const declaredHeaders = [];
                    const seenHeaderKeys = new Set();

                    declaredHeadersRaw.forEach(headerName => {
                        const trimmed = (headerName ?? '').trim();
                        if (!trimmed) {
                            return;
                        }
                        const normalized = normalizeHeader(trimmed);
                        if (!normalized.length || seenHeaderKeys.has(normalized)) {
                            return;
                        }
                        seenHeaderKeys.add(normalized);
                        declaredHeaders.push({ label: trimmed, normalized });
                    });

                    if (!declaredHeaders.length && mapping.target) {
                        const column = activeProfileColumns.find(col => col.target === mapping.target);
                        if (column) {
                            const normalized = normalizeHeader(column.header ?? mapping.target);
                            if (!seenHeaderKeys.has(normalized)) {
                                seenHeaderKeys.add(normalized);
                                declaredHeaders.push({ label: column.header ?? mapping.target, normalized });
                            }
                        }
                    }

                    const candidates = [];
                    declaredHeaders.forEach(({ label: declaredLabel, normalized }) => {
                        const headerInfo = normalized ? resolvedHeaderMap.get(normalized) : undefined;
                        const columnDefinition = headerInfo?.column
                            ?? activeProfileColumns.find(col => normalizeHeader(col.header) === normalized)
                            ?? null;
                        const targetKey = headerInfo?.column?.target
                            ?? columnDefinition?.target
                            ?? mapping.target
                            ?? null;
                        const originalHeader = headerInfo?.originalHeader
                            ?? columnDefinition?.header
                            ?? declaredLabel;
                        const index = headerInfo ? headerInfo.index : -1;

                        candidates.push({
                            declaredHeader: declaredLabel,
                            normalizedHeader: normalized,
                            originalHeader,
                            column: columnDefinition,
                            target: targetKey,
                            index
                        });
                    });

                    if (!candidates.length && mapping.target) {
                        const info = resolvedTargetMap.get(mapping.target);
                        const columnDefinition = info?.column
                            ?? activeProfileColumns.find(col => col.target === mapping.target)
                            ?? null;
                        const normalized = columnDefinition ? normalizeHeader(columnDefinition.header ?? mapping.target) : '';
                        candidates.push({
                            declaredHeader: columnDefinition?.header ?? mapping.target,
                            normalizedHeader: normalized,
                            originalHeader: info?.originalHeader ?? columnDefinition?.header ?? mapping.target,
                            column: columnDefinition,
                            target: mapping.target,
                            index: info ? info.index : -1
                        });
                    }

                    const columnMissing = !candidates.length || candidates.every(candidate => candidate.index === -1);
                    const structurallyMissing = required && columnMissing && !fallbackValue;

                    if (structurallyMissing) {
                        missingRequiredFields.push(label);
                    }

                    const displayHeaders = candidates.map(candidate => candidate.declaredHeader);

                    const fieldConfig = {
                        field: mapping.field,
                        label,
                        displayHeaders,
                        target: mapping.target ?? null,
                        fallback: fallbackValue,
                        required,
                        candidates,
                        hasLiteralFallback: Boolean(fallbackValue),
                        columnMissing,
                        isExpenseTypeField: mapping.field === 'expenseType'
                    };

                    if (mapping.field === 'date') {
                        prioritizedFields.push(fieldConfig);
                    } else {
                        regularFields.push(fieldConfig);
                    }
                });

                previewFields = prioritizedFields.concat(regularFields);

                const hasCategoryField = previewFields.some(field => field.field === 'categoryId');
                if (!hasCategoryField) {
                    const categoryLabel = getExpenseFieldLabel('categoryId');
                    previewFields.push({
                        field: 'categoryId',
                        label: categoryLabel,
                        displayHeaders: [],
                        target: null,
                        fallback: null,
                        required: true,
                        candidates: [],
                        hasLiteralFallback: false,
                        columnMissing: true,
                        isExpenseTypeField: false
                    });
                    missingRequiredFields.push(categoryLabel);
                }

                logEvent('info', 'Preview field configuration prepared', {
                    totalFields: previewFields.length,
                    missingRequiredFields: missingRequiredFields.length,
                    headerIndex
                });

                return { success: true, headerIndex };
            }

            function parseAmount(rawValue) {
                if (rawValue == null) return null;
                const parser = getParserSettings();
                const decimalSeparator = parser.decimalSeparator || ',';
                let sanitized = rawValue.toString().trim();
                if (!sanitized) return null;
                sanitized = sanitized.replace(/\s+/g, '');
                const separatorRegex = new RegExp(`\\${decimalSeparator}`, 'g');
                sanitized = sanitized.replace(separatorRegex, '.');
                sanitized = sanitized.replace(/[^0-9.+-]/g, '');
                if (!sanitized.length) return null;
                const numeric = Number(sanitized);
                return Number.isNaN(numeric) ? null : numeric;
            }

            function formatNumber(value) {
                if (value == null || Number.isNaN(value)) {
                    return '';
                }
                return value.toLocaleString('cs-CZ', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
            }

            function applyTransform(column, rawMap) {
                const rawValue = rawMap[column.target];
                if (rawValue == null || rawValue === '') {
                    return '';
                }

                if (!column.transform) {
                    return rawValue;
                }

                switch (column.transform) {
                    case 'signedAmount': {
                        const numeric = parseAmount(rawValue);
                        return numeric == null ? rawValue : formatNumber(numeric);
                    }
                    case 'directionSignedAmount': {
                        const numeric = parseAmount(rawValue);
                        if (numeric == null) {
                            return rawValue;
                        }
                        const directionRaw = rawMap.direction ?? rawMap['direction'];
                        const normalized = normalizeHeader(directionRaw);
                        let signed = numeric;
                        if (normalized.includes('prichozi') || normalized.includes('incoming')) {
                            signed = Math.abs(numeric);
                        } else if (normalized.includes('odchozi') || normalized.includes('outgoing')) {
                            signed = -Math.abs(numeric);
                        }
                        return formatNumber(signed);
                    }
                    default:
                        return rawValue;
                }
            }

            function computeDirectionSignedAmount(rawMap, candidate) {
                if (!candidate || !candidate.target) {
                    return null;
                }

                const amountRaw = rawMap[candidate.target];
                const numeric = parseAmount(amountRaw);
                if (numeric == null) {
                    return null;
                }

                const directionValue = rawMap.direction ?? rawMap['direction'];
                if (directionValue == null || directionValue === '') {
                    return numeric;
                }

                const normalized = normalizeText(directionValue);
                if (normalized.includes('prichozi') || normalized.includes('incoming')) {
                    return Math.abs(numeric);
                }
                if (normalized.includes('odchozi') || normalized.includes('outgoing')) {
                    return -Math.abs(numeric);
                }

                return numeric;
            }

            function parseDateWithFormat(rawValue, format) {
                if (rawValue == null) {
                    return null;
                }

                const text = rawValue.toString().trim();
                if (!text.length) {
                    return null;
                }

                const effectiveFormat = typeof format === 'string' && format.length ? format : 'yyyy-MM-dd';
                const tokenRegex = /(yyyy|yy|MM|M|dd|d)/g;
                const tokens = [];
                let match;
                while ((match = tokenRegex.exec(effectiveFormat)) !== null) {
                    tokens.push(match[0]);
                }

                const numberMatches = text.match(/\d+/g);
                const components = { year: null, month: null, day: null };

                if (numberMatches && tokens.length) {
                    for (let i = 0; i < numberMatches.length && i < tokens.length; i++) {
                        const numericValue = Number.parseInt(numberMatches[i], 10);
                        if (Number.isNaN(numericValue)) {
                            continue;
                        }

                        const token = tokens[i];
                        if (token === 'yyyy') {
                            components.year = numericValue;
                        } else if (token === 'yy') {
                            components.year = numericValue + (numericValue >= 70 ? 1900 : 2000);
                        } else if (token === 'MM' || token === 'M') {
                            components.month = numericValue;
                        } else if (token === 'dd' || token === 'd') {
                            components.day = numericValue;
                        }
                    }
                }

                if (components.year == null || components.month == null || components.day == null) {
                    const fallback = new Date(text);
                    if (Number.isNaN(fallback.getTime())) {
                        return null;
                    }
                    return fallback.toISOString().slice(0, 10);
                }

                const date = new Date(Date.UTC(components.year, components.month - 1, components.day));
                if (Number.isNaN(date.getTime())) {
                    return null;
                }

                return date.toISOString().slice(0, 10);
            }

            function computeFieldValueForImport(fieldConfig, rawMap, valueResult) {
                if (!fieldConfig || !fieldConfig.field || fieldConfig.field === 'expenseType') {
                    return null;
                }

                const candidate = valueResult?.usedCandidate ?? null;
                const fallbackValue = fieldConfig.fallback ?? null;
                const rawValue = candidate && candidate.target ? rawMap[candidate.target] : (valueResult?.rawValue ?? null);

                switch (fieldConfig.field) {
                    case 'amount': {
                        if (candidate?.column?.transform === 'directionSignedAmount') {
                            const directionAmount = computeDirectionSignedAmount(rawMap, candidate);
                            if (directionAmount != null) {
                                return Math.abs(directionAmount);
                            }
                        }

                        const parsed = parseAmount(rawValue ?? fallbackValue ?? valueResult?.displayValue);
                        return parsed != null ? Math.abs(parsed) : null;
                    }
                    case 'date': {
                        const parser = getParserSettings();
                        return parseDateWithFormat(rawValue ?? fallbackValue ?? valueResult?.displayValue, parser.dateFormat);
                    }
                    case 'currency': {
                        const currencyCandidate = rawValue ?? fallbackValue ?? valueResult?.displayValue;
                        if (currencyCandidate == null) {
                            return null;
                        }
                        const normalized = currencyCandidate.toString().trim().toUpperCase();
                        return normalized.length ? normalized : null;
                    }
                    default: {
                        const textCandidate = rawValue ?? fallbackValue ?? valueResult?.displayValue;
                        if (textCandidate == null) {
                            return fieldConfig.field === 'name' ? 'Imported transaction' : null;
                        }
                        if (typeof textCandidate === 'string') {
                            const trimmed = textCandidate.trim();
                            if (!trimmed.length) {
                                return fieldConfig.field === 'name' ? 'Imported transaction' : null;
                            }
                            return trimmed;
                        }
                        return textCandidate;
                    }
                }
            }

            function buildRawValueMap(row) {
                const raw = {};
                activeProfileColumns.forEach(column => {
                    const info = resolvedTargetMap.get(column.target);
                    if (info && info.index !== -1) {
                        raw[column.target] = (row[info.index] ?? '').trim();
                    } else {
                        raw[column.target] = null;
                    }
                });
                return raw;
            }

            function getDisplayValueForField(fieldConfig, rawMap) {
                const candidates = Array.isArray(fieldConfig.candidates) ? fieldConfig.candidates : [];

                for (const candidate of candidates) {
                    if (!candidate || !candidate.target) {
                        continue;
                    }

                    const rawValue = rawMap[candidate.target];
                    const hasRaw = rawValue !== null && rawValue !== undefined && rawValue !== '';
                    let transformed = '';

                    if (candidate.column) {
                        transformed = applyTransform(candidate.column, rawMap);
                    }

                    if (transformed !== '' && transformed !== null && transformed !== undefined) {
                        return {
                            rawValue,
                            displayValue: transformed,
                            usedCandidate: candidate,
                            fromFallback: false
                        };
                    }

                    if (hasRaw) {
                        return {
                            rawValue,
                            displayValue: rawValue,
                            usedCandidate: candidate,
                            fromFallback: false
                        };
                    }
                }

                if (fieldConfig.fallback) {
                    return {
                        rawValue: fieldConfig.fallback,
                        displayValue: fieldConfig.fallback,
                        usedCandidate: null,
                        fromFallback: true
                    };
                }

                return {
                    rawValue: null,
                    displayValue: '',
                    usedCandidate: null,
                    fromFallback: false
                };
            }

            async function renderPreview({ requested = currentSkipRows } = {}) {
                const container = containerEl();
                const head = headEl();
                const body = bodyEl();

                if (!container || !head || !body) {
                    return;
                }

                const result = computePreviewModel();
                if (!result.success) {
                    logEvent('warn', `Preview computation failed: ${result.reason}`);
                    setStatus(result.reason, 'warning');
                    clearPreviewTable();
                    updateImportButtonState(false);
                    return;
                }

                // Check for duplicate expenses
                let existingExpenses = [];
                try {
                    const dates = latestDataRows
                        .map((row, index) => {
                            const rawMap = buildRawValueMap(row);
                            const dateField = previewFields.find(f => f.field === 'date');
                            if (!dateField) return null;
                            const valueResult = getDisplayValueForField(dateField, rawMap);
                            const importValue = computeFieldValueForImport(dateField, rawMap, valueResult);
                            return typeof importValue === 'string' && importValue.trim().length ? importValue.trim() : null;
                        })
                        .filter(date => date !== null);

                    if (dates.length > 0) {
                        const minDate = dates.reduce((min, date) => date < min ? date : min);
                        const maxDate = dates.reduce((max, date) => date > max ? date : max);

                        logEvent('info', `Checking for duplicate expenses between ${minDate} and ${maxDate}`);

                        const response = await fetch(`/api/expenses/irregular?startDate=${encodeURIComponent(minDate)}&endDate=${encodeURIComponent(maxDate)}`);
                        if (response.ok) {
                            existingExpenses = await response.json();
                            // Normalize dates to yyyy-MM-dd format for comparison
                            existingExpenses = existingExpenses.map(expense => ({
                                ...expense,
                                date: normalizeDateString(expense.date) ?? (typeof expense.date === 'string' ? expense.date.trim() : '')
                            })).filter(expense => expense.date.length > 0);
                            logEvent('info', `Found ${existingExpenses.length} existing expenses in date range`);
                        } else {
                            logEvent('warn', `Failed to fetch existing expenses: ${response.status}`);
                        }
                    }
                } catch (error) {
                    logEvent('error', 'Error checking for duplicate expenses', error);
                }

                function normalizeDateString(value) {
                    if (value == null) {
                        return null;
                    }

                    if (value instanceof Date && !Number.isNaN(value.getTime())) {
                        return value.toISOString().slice(0, 10);
                    }

                    const text = value.toString().trim();
                    if (!text.length) {
                        return null;
                    }

                    const isoPrefixMatch = text.match(/^(\d{4}-\d{2}-\d{2})/);
                    if (isoPrefixMatch && isoPrefixMatch[1]) {
                        return isoPrefixMatch[1];
                    }

                    const parsed = new Date(text);
                    if (!Number.isNaN(parsed.getTime())) {
                        return parsed.toISOString().slice(0, 10);
                    }

                    return null;
                }

                // Helper function to check if an expense is a duplicate
                function isDuplicateExpense(importAmount, importDate, importName, importCurrency) {
                    if (!existingExpenses.length) {
                        return { isDuplicate: false };
                    }

                    // Normalize the import amount to absolute value and 2 decimal places
                    const normalizedImportAmount = Math.round(Math.abs(importAmount) * 100) / 100;
                    const normalizedImportDate = normalizeDateString(importDate);

                    if (!normalizedImportDate) {
                        return { isDuplicate: false };
                    }

                    for (const existing of existingExpenses) {
                        // Normalize the existing amount to absolute value and 2 decimal places
                        const normalizedExistingAmount = Math.round(Math.abs(Number(existing.amount)) * 100) / 100;
                        const normalizedExistingDate = normalizeDateString(existing.date);

                        if (!normalizedExistingDate || Number.isNaN(normalizedExistingAmount)) {
                            continue;
                        }

                        // Check if normalized absolute amounts match (within small tolerance for floating point)
                        const amountMatch = Math.abs(normalizedExistingAmount - normalizedImportAmount) < 0.01;
                        // Check if dates match
                        const dateMatch = normalizedExistingDate === normalizedImportDate;

                        if (amountMatch && dateMatch) {
                            return {
                                isDuplicate: true,
                                matchingExpense: existing
                            };
                        }
                    }

                    return { isDuplicate: false };
                }

                if (!previewFields.length) {
                    logEvent('warn', 'No expense field mappings available after computation.');
                    setStatus('No fields available to preview for this profile.', 'warning');
                    clearPreviewTable();
                    updateImportButtonState(false);
                    return;
                }

                head.replaceChildren();
                const headerRow = head;
                const selectTh = document.createElement('th');
                selectTh.scope = 'col';
                selectTh.className = 'text-center';
                const selectAllWrapper = document.createElement('div');
                selectAllWrapper.className = 'form-check d-inline-flex justify-content-center m-0';
                const selectAllInput = document.createElement('input');
                selectAllInput.type = 'checkbox';
                selectAllInput.className = 'form-check-input';
                selectAllInput.id = selectAllCheckboxId;
                selectAllInput.setAttribute('aria-label', 'Select or deselect all transactions');
                selectAllInput.addEventListener('change', event => {
                    const shouldSelect = event.target.checked;
                    event.target.indeterminate = false;
                    handleSelectAllToggle(shouldSelect);
                });
                selectAllWrapper.appendChild(selectAllInput);
                selectTh.appendChild(selectAllWrapper);
                headerRow.appendChild(selectTh);

                const indexTh = document.createElement('th');
                indexTh.scope = 'col';
                indexTh.className = 'text-muted';
                indexTh.textContent = '#';
                headerRow.appendChild(indexTh);

                previewFields.forEach(fieldConfig => {
                    const th = document.createElement('th');
                    th.scope = 'col';

                    const titleDiv = document.createElement('div');
                    titleDiv.textContent = fieldConfig.label;
                    th.appendChild(titleDiv);

                    const candidateHeaders = Array.isArray(fieldConfig.candidates) ? fieldConfig.candidates : [];
                    if (candidateHeaders.length) {
                        const primaryHeader = candidateHeaders[0]?.originalHeader ?? candidateHeaders[0]?.declaredHeader ?? '';
                        const fallbackHeaders = candidateHeaders
                            .slice(1)
                            .map(candidate => candidate.originalHeader ?? candidate.declaredHeader)
                            .filter(Boolean);
                        const headerTextParts = [];
                        if (primaryHeader) {
                            headerTextParts.push(primaryHeader);
                        }
                        if (fallbackHeaders.length) {
                            headerTextParts.push(`fallback: ${fallbackHeaders.join(', ')}`);
                        }
                        if (headerTextParts.length) {
                            const sourceDiv = document.createElement('div');
                            sourceDiv.className = 'small text-muted';
                            sourceDiv.textContent = headerTextParts.join(' â€¢ ');
                            th.appendChild(sourceDiv);
                        }
                    } else if (fieldConfig.hasLiteralFallback) {
                        const fallbackDiv = document.createElement('div');
                        fallbackDiv.className = 'small text-muted';
                        fallbackDiv.textContent = `default: ${fieldConfig.fallback}`;
                        th.appendChild(fallbackDiv);
                    }

                    if (fieldConfig.columnMissing && !fieldConfig.hasLiteralFallback) {
                        th.classList.add(fieldConfig.required ? 'import-missing-header' : 'import-optional-header');
                        if (!fieldConfig.required) {
                            const badge = document.createElement('span');
                            badge.className = 'badge bg-secondary text-light ms-2';
                            badge.textContent = 'Optional missing';
                            th.appendChild(badge);
                        }
                    }

                    headerRow.appendChild(th);
                });

                const missingSet = new Set(missingRequiredFields);

                body.replaceChildren();
                previewRowData = new Array(latestDataRows.length).fill(null);
                expenseTypeControlMap.clear();
                rowSelectionControlMap = new Map();
                const nextSelectionState = new Map();
                let validRowCount = 0;

                latestDataRows.forEach((row, rowIndex) => {
                    const rawMap = buildRawValueMap(row);
                    const tr = document.createElement('tr');
                    tr.classList.add('align-middle');

                    const selectTd = document.createElement('td');
                    selectTd.className = 'text-center';
                    const selectCheckbox = document.createElement('input');
                    selectCheckbox.type = 'checkbox';
                    selectCheckbox.className = 'form-check-input';
                    selectCheckbox.setAttribute('aria-label', `Select transaction row ${rowIndex + 1}`);
                    selectTd.appendChild(selectCheckbox);
                    tr.appendChild(selectTd);

                    const rowIndexCell = document.createElement('th');
                    rowIndexCell.scope = 'row';
                    rowIndexCell.className = 'text-muted';
                    rowIndexCell.textContent = String(rowIndex + 1);
                    tr.appendChild(rowIndexCell);

                    const rowPayload = { sourceRowNumber: rowIndex + 1 };
                    previewRowData[rowIndex] = rowPayload;
                    const missingFieldsForRow = new Set();
                    rowPayload.missingRequiredFields = missingFieldsForRow;
                    rowPayload.wasDeselectedDueToInvalid = false;

                    previewFields.forEach(fieldConfig => {
                        const td = document.createElement('td');
                        const valueResult = getDisplayValueForField(fieldConfig, rawMap);

                        if (fieldConfig.isExpenseTypeField) {
                            const selection = ensureExpenseTypeSelection(rowIndex, valueResult.displayValue, rowPayload, valueResult);
                            const select = buildExpenseTypeSelect(rowIndex, selection);
                            expenseTypeControlMap.set(rowIndex, select);
                            td.appendChild(select);
                            rowPayload.expenseType = selection.expenseType;
                            rowPayload.familyMemberId = selection.familyMemberId;
                        } else {
                            const displayValue = valueResult.displayValue;
                            const importValue = computeFieldValueForImport(fieldConfig, rawMap, valueResult);
                            const fieldLabel = fieldConfig.label ?? fieldConfig.field ?? `Field ${rowIndex + 1}`;
                            const importValueMissing = fieldConfig.required && (
                                importValue === null
                                || importValue === ''
                                || (typeof importValue === 'number' && !Number.isFinite(importValue))
                            );

                            if (fieldConfig.field === 'name') {
                                const nameInput = document.createElement('input');
                                nameInput.type = 'text';
                                nameInput.className = 'form-control form-control-sm';
                                nameInput.placeholder = 'Expense name';
                                const initialValue = typeof importValue === 'string'
                                    ? importValue
                                    : (typeof displayValue === 'string' ? displayValue : '');
                                nameInput.value = initialValue ?? '';

                                const nameMissingLabel = fieldConfig.label ?? fieldLabels.name ?? 'Expense Name';

                                const hint = document.createElement('div');
                                hint.className = 'small import-invalid-hint mt-1';
                                hint.textContent = 'Name is required';

                                const applyNameValidity = isValid => {
                                    if (isValid) {
                                        td.classList.remove('import-invalid-cell');
                                        if (hint.parentElement === td) {
                                            hint.remove();
                                        }
                                    } else {
                                        td.classList.add('import-invalid-cell');
                                        if (hint.parentElement !== td) {
                                            td.appendChild(hint);
                                        }
                                    }
                                };

                                const updateNameState = value => {
                                    const trimmed = value.trim();
                                    const hasValue = trimmed.length > 0;
                                    rowPayload.name = hasValue ? trimmed : null;
                                    if (fieldConfig.required) {
                                        if (hasValue) {
                                            missingFieldsForRow.delete(nameMissingLabel);
                                            applyNameValidity(true);
                                        } else {
                                            missingFieldsForRow.add(nameMissingLabel);
                                            applyNameValidity(false);
                                            missingSet.add(nameMissingLabel);
                                        }
                                    } else if (hasValue) {
                                        rowPayload.name = trimmed;
                                    }
                                };

                                updateNameState(nameInput.value);

                                nameInput.addEventListener('input', event => {
                                    updateNameState(event.target.value);
                                    const payload = previewRowData[rowIndex];
                                    if (payload) {
                                        payload.missingRequiredFields = missingFieldsForRow;
                                    }
                                    updateRowValidityFromFieldChange(rowIndex);
                                });

                                td.appendChild(nameInput);
                            } else if (fieldConfig.field === 'categoryId') {
                                const categoryLabel = fieldConfig.label ?? expenseFieldLabels.categoryId ?? 'Category';
                                const categorySelect = document.createElement('select');
                                categorySelect.className = 'form-select form-select-sm';
                                categorySelect.setAttribute('aria-label', `Category for row ${rowIndex + 1}`);

                                const defaultOption = document.createElement('option');
                                defaultOption.value = '';
                                defaultOption.textContent = availableExpenseCategories.length ? 'Select category' : 'No categories available';
                                categorySelect.appendChild(defaultOption);

                                availableExpenseCategories.forEach(category => {
                                    const option = document.createElement('option');
                                    option.value = String(category.id);
                                    option.textContent = category.name;
                                    categorySelect.appendChild(option);
                                });

                                const detectionNote = document.createElement('div');
                                detectionNote.className = 'small import-detection-note mt-1';

                                const applyCategoryValidity = isValid => {
                                    if (isValid) {
                                        categorySelect.classList.remove('border', 'border-danger');
                                        td.classList.remove('import-invalid-cell');
                                    } else {
                                        categorySelect.classList.add('border', 'border-danger');
                                        td.classList.remove('import-invalid-cell');
                                    }
                                };

                                const applyDetectionNote = message => {
                                    if (!message || !message.trim().length) {
                                        if (detectionNote.parentElement === td) {
                                            detectionNote.remove();
                                        }
                                        return;
                                    }
                                    detectionNote.textContent = message;
                                    if (detectionNote.parentElement !== td) {
                                        td.appendChild(detectionNote);
                                    }
                                };

                                td.appendChild(categorySelect);

                                const setCategorySelection = categoryId => {
                                    if (categoryId != null && getExpenseCategoryById(categoryId)) {
                                        rowPayload.categoryId = categoryId;
                                        missingFieldsForRow.delete(categoryLabel);
                                        applyCategoryValidity(true);
                                        if (categorySelect.value !== String(categoryId)) {
                                            categorySelect.value = String(categoryId);
                                        }
                                        applyDetectionNote('');
                                        return true;
                                    }

                                    rowPayload.categoryId = null;
                                    missingFieldsForRow.add(categoryLabel);
                                    applyCategoryValidity(false);
                                    if (categorySelect.value !== '') {
                                        categorySelect.value = '';
                                    }
                                    return false;
                                };

                                let initialCategoryId = null;

                                if (rowPayload.categoryId != null) {
                                    const numericExisting = Number(rowPayload.categoryId);
                                    if (Number.isFinite(numericExisting)) {
                                        initialCategoryId = numericExisting;
                                    }
                                }

                                if (initialCategoryId == null && !importValueMissing) {
                                    initialCategoryId = resolveCategoryId(importValue);
                                }

                                let detectedText = '';

                                if (typeof displayValue === 'string' && displayValue.trim().length) {
                                    detectedText = displayValue.trim();
                                } else if (typeof importValue === 'string' && importValue.trim().length) {
                                    detectedText = importValue.trim();
                                }

                                if (initialCategoryId == null && detectedText.length) {
                                    const resolvedFromDetected = resolveCategoryId(detectedText);
                                    if (resolvedFromDetected != null) {
                                        initialCategoryId = resolvedFromDetected;
                                    }
                                }

                                const categoryValid = setCategorySelection(initialCategoryId);
                                if (!categoryValid) {
                                    missingSet.add(categoryLabel);
                                    if (detectedText.length) {
                                        applyDetectionNote(`Detected value: ${detectedText} (no matching category)`);
                                    }
                                }

                                categorySelect.addEventListener('change', event => {
                                    const selectedValue = event.target.value;
                                    const numericId = Number.parseInt(selectedValue, 10);
                                    const validSelection = setCategorySelection(Number.isNaN(numericId) ? null : numericId);
                                    if (validSelection) {
                                        applyDetectionNote('');
                                    }
                                    rowPayload.missingRequiredFields = missingFieldsForRow;
                                    updateRowValidityFromFieldChange(rowIndex);
                                });

                                if (!availableExpenseCategories.length) {
                                    categorySelect.disabled = true;
                                    categorySelect.classList.remove('border', 'border-danger');
                                    missingSet.add(categoryLabel);
                                }
                            } else {
                                if (fieldConfig.field && fieldConfig.field !== 'expenseType') {
                                    rowPayload[fieldConfig.field] = importValueMissing ? null : importValue;
                                }

                                const valuePresent = displayValue !== null && displayValue !== undefined && displayValue !== '';

                                if (importValueMissing) {
                                    missingFieldsForRow.add(fieldLabel);
                                    td.classList.add('import-invalid-cell');

                                    if (valuePresent) {
                                        const valueSpan = document.createElement('span');
                                        valueSpan.className = 'text-danger';
                                        valueSpan.textContent = displayValue;
                                        td.appendChild(valueSpan);
                                    } else {
                                        const placeholder = document.createElement('span');
                                        placeholder.className = 'text-danger';
                                        placeholder.textContent = 'â€”';
                                        td.appendChild(placeholder);
                                    }

                                    const hint = document.createElement('div');
                                    hint.className = 'small import-invalid-hint mt-1';
                                    if (fieldConfig.field === 'amount') {
                                        hint.textContent = 'Unable to parse amount';
                                    } else if (fieldConfig.field === 'date') {
                                        hint.textContent = 'Unable to parse date';
                                    } else {
                                        hint.textContent = 'Required value missing';
                                    }
                                    td.appendChild(hint);

                                    missingSet.add(fieldLabel);
                                    logEvent('warn', 'Import value could not be parsed', {
                                        field: fieldConfig.field,
                                        rowIndex: rowIndex + 1,
                                        rawValue: valueResult.rawValue
                                    });
                                } else if (!valuePresent) {
                                    const placeholder = document.createElement('span');
                                    placeholder.className = fieldConfig.required ? 'text-danger' : 'text-muted';
                                    placeholder.textContent = 'â€”';
                                    td.appendChild(placeholder);
                                    if (fieldConfig.required) {
                                        td.classList.add('import-invalid-cell');
                                        missingFieldsForRow.add(fieldLabel);
                                        missingSet.add(fieldLabel);
                                    }
                                } else {
                                    const valueSpan = document.createElement('span');
                                    valueSpan.textContent = displayValue;
                                    td.appendChild(valueSpan);
                                    td.classList.remove('import-invalid-cell');
                                }
                            }
                        }

                        tr.appendChild(td);
                    });

                    let selection = expenseTypeSelectionMap.get(rowIndex);
                    if (rowPayload.familyMemberId != null) {
                        const member = getFamilyMemberById(rowPayload.familyMemberId);
                        if (member) {
                            selection = { expenseType: 'Individual', familyMemberId: member.id };
                            expenseTypeSelectionMap.set(rowIndex, selection);
                        }
                    }

                    if (!selection) {
                        selection = { expenseType: 'Family', familyMemberId: null };
                        expenseTypeSelectionMap.set(rowIndex, selection);
                    }

                    rowPayload.expenseType = selection.expenseType;
                    rowPayload.familyMemberId = selection.familyMemberId;

                    const control = expenseTypeControlMap.get(rowIndex);
                    if (control) {
                        control.value = encodeExpenseTypeSelection(selection);
                    }

                    const rowIsValid = missingFieldsForRow.size === 0;
                    rowPayload.isValid = rowIsValid;
                    if (rowIsValid) {
                        validRowCount += 1;
                    }

                    // Check for duplicates
                    const importAmount = typeof rowPayload.amount === 'number' && Number.isFinite(rowPayload.amount) ? rowPayload.amount : null;
                    const importDate = typeof rowPayload.date === 'string' && rowPayload.date.trim().length ? rowPayload.date.trim() : null;
                    const importName = typeof rowPayload.name === 'string' && rowPayload.name.trim().length ? rowPayload.name.trim() : 'Imported transaction';
                    const importCurrency = typeof rowPayload.currency === 'string' && rowPayload.currency.trim().length ? rowPayload.currency.trim().toUpperCase() : null;

                    const duplicateResult = importAmount !== null && importDate !== null && importCurrency !== null ?
                                          isDuplicateExpense(importAmount, importDate, importName, importCurrency) :
                                          { isDuplicate: false };
                    const isDuplicate = duplicateResult.isDuplicate;
                    rowPayload.isDuplicate = isDuplicate;
                    rowPayload.matchingExpense = duplicateResult.matchingExpense;

                    if (isDuplicate) {
                        tr.classList.add('duplicate-row');
                        const duplicateBadge = document.createElement('span');
                        duplicateBadge.className = 'duplicate-badge me-2';
                        duplicateBadge.textContent = 'Duplicate';
                        const matching = duplicateResult.matchingExpense;
                        if (matching) {
                            const details = [matching.name];
                            if (matching.date) {
                                details.push(`on ${matching.date}`);
                            }
                            if (matching.amount && matching.currency) {
                                details.push(`(${matching.amount} ${matching.currency})`);
                            }
                            duplicateBadge.title = `Already logged as ${details.join(' ')}`.trim();
                        } else {
                            duplicateBadge.title = 'This line already exists in expenses.';
                        }
                        rowIndexCell.appendChild(duplicateBadge);
                    }

                    const previousSelection = rowSelectionState.has(rowIndex)
                        ? Boolean(rowSelectionState.get(rowIndex))
                        : undefined;
                    const isSelected = rowIsValid && !isDuplicate && (previousSelection ?? true);

                    if (!rowIsValid) {
                        selectCheckbox.checked = false;
                        selectCheckbox.disabled = true;
                        selectCheckbox.title = 'Resolve required fields to import this row.';
                        rowPayload.wasDeselectedDueToInvalid = true;
                    } else if (isDuplicate) {
                        selectCheckbox.checked = false;
                        selectCheckbox.disabled = true;
                        selectCheckbox.title = 'This appears to be a duplicate expense.';
                        rowPayload.wasDeselectedDueToDuplicate = true;
                    } else {
                        selectCheckbox.checked = isSelected;
                        selectCheckbox.disabled = false;
                        selectCheckbox.title = '';
                        rowPayload.wasDeselectedDueToInvalid = false;
                        rowPayload.wasDeselectedDueToDuplicate = false;
                    }

                    rowSelectionControlMap.set(rowIndex, selectCheckbox);
                    nextSelectionState.set(rowIndex, rowIsValid && !isDuplicate ? Boolean(selectCheckbox.checked) : false);

                    selectCheckbox.addEventListener('change', event => {
                        const payload = previewRowData[rowIndex];
                        if (payload) {
                            payload.wasDeselectedDueToInvalid = false;
                        }
                        setRowSelection(rowIndex, event.target.checked);
                        refreshSelectionState();
                    });

                    body.appendChild(tr);
                });

                rowSelectionState = nextSelectionState;
                refreshSelectionState();

                previewStatusContext = {
                    profileName: getProfileDisplayName(),
                    fileName: currentFileName ?? 'Statement',
                    requestedSkipRows: requested,
                    appliedSkipRows: currentSkipRows,
                    totalRows: latestDataRows.length
                };

                const statusParts = [];
                statusParts.push(`${getProfileDisplayName()} profile`);
                statusParts.push(`${currentFileName ?? 'Statement'} loaded.`);
                if (requested !== currentSkipRows) {
                    statusParts.push(`Requested ${requested} metadata row${requested === 1 ? '' : 's'}, using ${currentSkipRows} after trimming.`);
                } else {
                    statusParts.push(`Skipped ${currentSkipRows} metadata row${currentSkipRows === 1 ? '' : 's'}.`);
                }
                statusParts.push(`Showing ${latestDataRows.length} transaction row${latestDataRows.length === 1 ? '' : 's'}.`);

                const uniqueMissing = [...missingSet];
                let statusType = 'success';
                if (uniqueMissing.length) {
                    statusParts.push(`Missing required fields: ${uniqueMissing.join(', ')}.`);
                    statusType = 'warning';
                    logEvent('warn', 'Missing required expense fields detected', uniqueMissing);
                }

                const duplicateCount = latestDataRows.reduce((count, row, index) => {
                    const payload = previewRowData[index];
                    return count + (payload && payload.isDuplicate ? 1 : 0);
                }, 0);

                if (duplicateCount > 0) {
                    statusParts.push(`${duplicateCount} potential duplicate${duplicateCount === 1 ? '' : 's'} found.`);
                    if (statusType === 'success') statusType = 'warning';
                    logEvent('warn', `${duplicateCount} potential duplicate expenses detected`);
                }

                if (!validRowCount) {
                    statusParts.push('No rows are currently ready to import.');
                    statusType = 'warning';
                }

                const selectedCount = getSelectedRowCount();
                const importableCount = validRowCount - duplicateCount;
                if (importableCount > 0) {
                    statusParts.push(`${selectedCount} of ${importableCount} importable row${importableCount === 1 ? '' : 's'} selected for import.`);
                }
                if (importableCount > 0 && selectedCount === 0) {
                    statusParts.push('Select at least one row to enable import.');
                }

                setStatus(statusParts.join(' '), statusType);
                container.classList.remove('d-none');

                logEvent('info', 'Preview rendered', {
                    rowsRendered: latestDataRows.length,
                    skipRows: currentSkipRows,
                    statusType,
                    validRowCount,
                    selectedCount
                });
            }

            function refreshSelectionState() {
                const button = submitButtonEl();
                if (!button) {
                    return;
                }

                const selectedCount = getSelectedRowCount();
                const hasSelection = selectedCount > 0;

                button.disabled = !hasSelection;
                if (hasSelection) {
                    button.title = `Import ${selectedCount} expense${selectedCount === 1 ? '' : 's'}`;
                } else {
                    button.title = 'Select at least one row to import';
                }

                const selectAllCheckbox = selectAllCheckboxEl();
                if (selectAllCheckbox) {
                    const totalSelectableRows = previewRowData.filter(row => row && row.isValid && !row.isDuplicate).length;
                    const selectedRows = getSelectedRowCount();
                    selectAllCheckbox.checked = totalSelectableRows > 0 && selectedRows === totalSelectableRows;
                    selectAllCheckbox.indeterminate = selectedRows > 0 && selectedRows < totalSelectableRows;
                }
            }

            function updateImportButtonState(enabled) {
                const button = submitButtonEl();
                if (!button) {
                    return;
                }

                button.disabled = !enabled;
                if (enabled) {
                    button.title = 'Import selected expenses';
                } else {
                    button.title = 'No expenses available to import';
                }
            }

            function buildImportPayload() {
                const rows = [];
                const totalPreviewRows = previewRowData.length;

                previewRowData.forEach((row, index) => {
                    if (!row) {
                        return;
                    }

                    if (!rowSelectionState.get(index)) {
                        return;
                    }

                    if (!row.isValid) {
                        return;
                    }

                    const amount = typeof row.amount === 'number' && Number.isFinite(row.amount) ? row.amount : null;
                    const currency = typeof row.currency === 'string' && row.currency.trim().length ? row.currency.trim().toUpperCase() : null;
                    const date = typeof row.date === 'string' && row.date.trim().length ? row.date.trim() : null;
                    const categoryId = typeof row.categoryId === 'number' && Number.isFinite(row.categoryId)
                        ? Math.trunc(row.categoryId)
                        : null;

                    if (amount == null || currency == null || date == null || categoryId == null) {
                        logEvent('warn', 'Skipping row due to missing required import value', {
                            rowIndex: index + 1,
                            hasAmount: amount != null,
                            hasCurrency: !!currency,
                            hasDate: !!date,
                            hasCategory: categoryId != null
                        });
                        return;
                    }

                    const roundedAmount = Math.round(amount * 100) / 100;
                    const nameCandidate = typeof row.name === 'string' && row.name.trim().length ? row.name.trim() : 'Imported transaction';
                    const expenseType = row.expenseType === 'Individual' ? 'Individual' : 'Family';
                    const familyMemberId = expenseType === 'Individual' && row.familyMemberId != null
                        ? Number(row.familyMemberId)
                        : null;

                    if (expenseType === 'Individual' && (familyMemberId == null || Number.isNaN(familyMemberId))) {
                        logEvent('warn', 'Skipping individual expense without valid family member', {
                            rowIndex: index + 1
                        });
                        return;
                    }

                    const sanitized = {
                        sourceRowNumber: row.sourceRowNumber ?? index + 1,
                        name: nameCandidate,
                        amount: roundedAmount,
                        currency,
                        date,
                        categoryId,
                        expenseType,
                        familyMemberId
                    };

                    if (row.memo && typeof row.memo === 'string') {
                        const memoText = row.memo.trim();
                        if (memoText.length) {
                            sanitized.memo = memoText;
                        }
                    }

                    rows.push(sanitized);
                });

                return {
                    profileId: activeProfile?.id ?? null,
                    profileVersion: activeProfile?.version ?? null,
                    skipRows: currentSkipRows,
                    originalRowCount: totalPreviewRows,
                    rows
                };
            }

            function setImportButtonLoading(isLoading) {
                const button = submitButtonEl();
                if (!button) {
                    return;
                }

                const labelSpan = button.querySelector('.default-label');
                let spinner = button.querySelector('.spinner-border');

                if (isLoading) {
                    if (labelSpan && !button.dataset.originalLabel) {
                        button.dataset.originalLabel = labelSpan.textContent ?? 'Import Expenses';
                    }

                    if (!spinner) {
                        spinner = document.createElement('span');
                        spinner.className = 'spinner-border spinner-border-sm me-2';
                        spinner.setAttribute('role', 'status');
                        spinner.setAttribute('aria-hidden', 'true');
                        button.insertBefore(spinner, button.firstChild);
                    }

                    if (labelSpan) {
                        labelSpan.textContent = 'Importing...';
                    }

                    button.disabled = true;
                } else {
                    if (spinner) {
                        spinner.remove();
                    }

                    delete button.dataset.originalLabel;
                    refreshSelectionState();
                }
            }

            async function performImport() {
                const button = submitButtonEl();
                if (!button || button.disabled) {
                    return;
                }

                if (!activeProfile) {
                    Toast.warning('Select a bank profile before importing.');
                    return;
                }

                const selectedCount = getSelectedRowCount();
                if (selectedCount === 0) {
                    Toast.warning('Select at least one transaction to import.');
                    return;
                }

                const payload = buildImportPayload();
                if (!payload.rows.length) {
                    Toast.warning('No valid expenses are ready to import. Check the preview for highlighted issues.');
                    return;
                }

                const antiforgeryToken = getAntiForgeryToken();
                if (!antiforgeryToken) {
                    Toast.error('Missing security token. Reload the page and try again.');
                    return;
                }

                const modalElement = document.getElementById(modalId);
                setImportButtonLoading(true);

                try {
                    logEvent('info', 'Submitting expense import request', {
                        profileId: payload.profileId,
                        rows: payload.rows.length
                    });

                    const url = new URL(window.location.href);
                    url.searchParams.set('handler', 'ImportExpenses');

                    const response = await fetch(`${url.pathname}${url.search}`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Accept': 'application/json',
                            'RequestVerificationToken': antiforgeryToken
                        },
                        body: JSON.stringify(payload)
                    });

                    let responseBody = null;
                    try {
                        responseBody = await response.json();
                    } catch (parseError) {
                        logEvent('error', 'Failed to parse expense import response as JSON', parseError);
                    }

                    if (!response.ok) {
                        const message = responseBody?.message ?? `Import failed with status ${response.status}.`;
                        Toast.error(message);
                        logEvent('error', 'Expense import request failed', {
                            status: response.status,
                            response: responseBody
                        });
                        return;
                    }

                    if (!responseBody) {
                        Toast.error('Import failed: empty server response.');
                        logEvent('error', 'Expense import response was empty despite successful status.');
                        return;
                    }

                    const importedCount = Number(responseBody.importedCount ?? 0);
                    const failedRows = Array.isArray(responseBody.failedRows) ? responseBody.failedRows : [];
                    const errors = Array.isArray(responseBody.errors) ? responseBody.errors : [];
                    const success = Boolean(responseBody.success);
                    const message = responseBody.message
                        ?? (success ? 'Expenses imported successfully.' : 'Import completed with warnings.');

                    const primaryError = errors.length ? errors[0] : null;
                    const messageWithDetail = primaryError != null && !success
                        ? `${message} ${primaryError}`
                        : message;

                    if (success) {
                        Toast.success(messageWithDetail);
                    } else if (importedCount > 0) {
                        Toast.warning(messageWithDetail);
                    } else {
                        Toast.error(messageWithDetail);
                    }

                    if (errors.length) {
                        logEvent('warn', 'Expense import completed with errors', errors);
                    }

                    if (failedRows.length) {
                        logEvent('warn', 'Expense import skipped specific rows', failedRows);
                    }

                    if (success || importedCount > 0) {
                        if (modalElement) {
                            const modalInstance = bootstrap.Modal.getInstance(modalElement);
                            if (modalInstance) {
                                modalInstance.hide();
                            }
                        }

                        setTimeout(() => {
                            window.location.reload();
                        }, 800);
                    }
                } catch (error) {
                    logEvent('error', 'Unexpected error during expense import', error);
                    Toast.error('Import failed due to an unexpected error.');
                } finally {
                    setImportButtonLoading(false);
                }
            }

            async function setSkipRows(value, { fromAuto = false } = {}) {
                if (!Number.isFinite(value)) {
                    value = 0;
                }
                value = Math.max(0, Math.min(value, Math.max(parsedRows.length - 1, 0)));
                requestedSkipRows = value;
                currentSkipRows = value;

                const skipInput = skipInputEl();
                if (skipInput && Number(skipInput.value) !== value) {
                    skipInput.value = String(value);
                }

                if (fromAuto) {
                    logEvent('info', `Applied auto-detected skip rows: ${value}`);
                    updateSkipDescription();
                }

                if (parsedRows.length) {
                    logEvent('debug', `Re-rendering preview with skip rows set to ${value}`);
                    await renderPreview({ requested: requestedSkipRows });
                }
            }

            async function handleParsedRows(rows) {
                logEvent('info', `Parsed ${rows.length} raw rows from CSV.`);
                let effectiveRows = rows.slice();
                const parser = getParserSettings();
                if (parser.trimEmptyPreamble) {
                    while (effectiveRows.length && !rowHasContent(effectiveRows[0])) {
                        effectiveRows.shift();
                    }
                }

                parsedRows = effectiveRows;
                autoSkipRows = determineAutoSkip(parsedRows);
                const defaultSkip = activeProfile ? Number(parser.defaultSkipRows ?? autoSkipRows) : autoSkipRows;
                currentSkipRows = Math.max(0, Math.min(defaultSkip, Math.max(parsedRows.length - 1, 0)));
                requestedSkipRows = currentSkipRows;

                enableSkipControls();

                const skipInput = skipInputEl();
                if (skipInput) {
                    skipInput.value = String(currentSkipRows);
                }

                await renderPreview({ requested: requestedSkipRows });
            }

            function parseCsv(text) {
                logEvent('debug', `Beginning CSV parse (length ${text.length}).`);
                const rows = [];
                const parser = getParserSettings();
                const delimiterChar = ((parser.delimiter ?? ';') || ';').charAt(0);
                const quoteChar = ((parser.quote ?? '"') || '"').charAt(0);
                let currentRow = [];
                let currentField = '';
                let inQuotes = false;

                function commitField() {
                    currentRow.push(currentField.trim());
                    currentField = '';
                }

                function commitRow() {
                    if (currentRow.length > 0) {
                        rows.push(currentRow);
                    }
                    currentRow = [];
                }

                for (let i = 0; i < text.length; i++) {
                    const char = text[i];

                    if (char === quoteChar) {
                        if (inQuotes && text[i + 1] === quoteChar) {
                            currentField += quoteChar;
                            i += 1;
                        } else {
                            inQuotes = !inQuotes;
                        }
                        continue;
                    }

                    if (char === delimiterChar && !inQuotes) {
                        commitField();
                        continue;
                    }

                    if ((char === '\n' || char === '\r') && !inQuotes) {
                        commitField();
                        commitRow();
                        if (char === '\r' && text[i + 1] === '\n') {
                            i += 1;
                        }
                        continue;
                    }

                    if (char === '\r' && inQuotes) {
                        continue;
                    }

                    currentField += char;
                }

                if (currentField.length || inQuotes) {
                    commitField();
                }
                if (currentRow.length) {
                    commitRow();
                }

                const filtered = rows.filter(row => rowHasContent(row));
                logEvent('debug', `CSV parse complete. Produced ${filtered.length} non-empty rows.`);
                return filtered;
            }

            function handleFile(file, { bypassProfileCheck = false } = {}) {
                logEvent('info', file ? `File input change detected: '${file.name}'` : 'File cleared.');
                if (!file) {
                    pendingFile = null;
                    resetPreview();
                    return;
                }

                if (!activeProfile && !bypassProfileCheck) {
                    const warningMessage = 'Select a bank profile before uploading a statement.';
                    pendingFile = file;
                    logEvent('warn', `File '${file.name}' selected without choosing a profile.`);
                    resetPreview(warningMessage, { clearFile: false });
                    setStatus(warningMessage, 'warning');
                    const profileSelect = profileSelectEl();
                    if (profileSelect) {
                        profileSelect.focus();
                    }
                    return;
                }

                pendingFile = null;
                currentFileName = file.name;
                showLoading(currentFileName);

                const reader = new FileReader();

                reader.onerror = () => {
                    showError('Failed to read the selected file. Please try again.');
                    logEvent('error', `FileReader encountered an error for '${file.name}'.`);
                };

                reader.onload = async event => {
                    try {
                        const text = event.target?.result ?? '';
                        if (!text) {
                            showError('The file appears to be empty.');
                            logEvent('warn', `File '${file.name}' contained no text.`);
                            return;
                        }

                        const rows = parseCsv(text);
                        if (!rows.length) {
                            showError('No rows detected in the file.');
                            logEvent('warn', `File '${file.name}' produced zero usable rows after parsing.`);
                            return;
                        }

                        await handleParsedRows(rows);
                        logEvent('info', `File '${file.name}' parsed successfully.`, {
                            totalRows: rows.length,
                            profile: getProfileDisplayName()
                        });
                    } catch (error) {
                        console.error('Error parsing CSV', error);
                        showError('Unable to parse the file. Make sure it is a valid CSV.');
                        logEvent('error', `Unhandled exception while parsing '${file.name}'.`, error);
                    }
                };

                const parser = getParserSettings();
                const encoding = parser.encoding || 'utf-8';
                try {
                    reader.readAsText(file, encoding);
                } catch (e) {
                    reader.readAsText(file);
                }
            }

            async function handleProfileChange(profileId) {
                activeProfile = bankProfiles.find(p => p.id === profileId) ?? null;
                activeProfileColumns = Array.isArray(activeProfile?.columns) ? activeProfile.columns : [];
                activeProfileMappings = Array.isArray(activeProfile?.expenseFieldMappings) ? activeProfile.expenseFieldMappings : [];

                const fileInput = fileInputEl();
                if (fileInput && !activeProfile) {
                    fileInput.value = '';
                }

                updateProfileDescription();
                if (!activeProfile) {
                    activeProfileMappings = [];
                    logEvent('info', 'Profile cleared. Preview reset.');
                    resetPreview();
                    return;
                }

                if (!parsedRows.length) {
                    const parser = getParserSettings();
                    currentSkipRows = requestedSkipRows = Number(parser.defaultSkipRows ?? 0);
                    const skipInput = skipInputEl();
                    if (skipInput) {
                        skipInput.value = String(currentSkipRows);
                    }

                    const fileInput = fileInputEl();
                    const candidateFile = pendingFile ?? fileInput?.files?.[0] ?? null;
                    if (candidateFile) {
                        logEvent('info', `Reprocessing pending file '${candidateFile.name}' after profile change to '${getProfileDisplayName()}'.`);
                        handleFile(candidateFile, { bypassProfileCheck: true });
                    } else {
                        disableSkipControls();
                        updateSkipDescription();
                        setStatus('Select a statement file to preview.', 'info');
                        logEvent('debug', `Profile '${getProfileDisplayName()}' ready. Awaiting file selection.`);
                    }
                    return;
                }

                const parser = getParserSettings();
                const profileSkip = Number(parser.defaultSkipRows ?? autoSkipRows);
                await setSkipRows(profileSkip);
                updateSkipDescription();
                logEvent('info', `Profile changed to '${getProfileDisplayName()}'. Applied skip rows ${profileSkip}.`);
            }

            document.addEventListener('DOMContentLoaded', function () {
                logEvent('info', 'Statement import module initializing.', {
                    profileCount: bankProfiles.length
                });
                const fileInput = fileInputEl();
                const modalElement = document.getElementById(modalId);
                const skipInput = skipInputEl();
                const autoButton = autoButtonEl();
                const profileSelect = profileSelectEl();

                if (profileSelect) {
                    if (!bankProfiles.length) {
                        profileSelect.disabled = true;
                        disableSkipControls('No bank profiles configured.');
                        const fileInput = fileInputEl();
                        if (fileInput) {
                            fileInput.disabled = true;
                            fileInput.value = '';
                        }
                        resetPreview('No bank profiles are available. Add YAML profiles under ImportProfiles/.');
                        logEvent('warn', 'No bank profiles available. File input disabled.');
                        return;
                    }

                    profileSelect.addEventListener('change', async event => {
                        await handleProfileChange(event.target?.value ?? '');
                    });
                } else {
                    setStatus('Bank profile selector not found.', 'warning');
                }

                if (fileInput) {
                    fileInput.addEventListener('change', event => {
                        const selectedFile = event.target?.files?.[0];
                        handleFile(selectedFile ?? null);
                    });
                }

                if (skipInput) {
                    skipInput.addEventListener('input', async event => {
                        const value = Number(event.target?.value ?? 0);
                        await setSkipRows(Number.isFinite(value) ? value : 0);
                    });
                }

                if (autoButton) {
                    autoButton.addEventListener('click', async () => {
                        await setSkipRows(autoSkipRows, { fromAuto: true });
                    });
                }

                const submitButton = submitButtonEl();
                if (submitButton) {
                    submitButton.addEventListener('click', event => {
                        event.preventDefault();
                        performImport();
                    });
                }

                if (modalElement) {
                    modalElement.addEventListener('hidden.bs.modal', () => {
                        logEvent('debug', 'Import modal hidden. Resetting preview state.');
                        resetPreview();
                    });
                    modalElement.addEventListener('shown.bs.modal', () => {
                        const status = statusEl();
                        if (status) {
                            status.focus({ preventScroll: true });
                        }
                        logEvent('debug', 'Import modal shown.');
                    });
                }

                disableSkipControls();
                updateProfileDescription();
                resetPreview();
                logEvent('info', 'Statement import module ready.');
            });
        })();
    </script>
    <script>
        // Create expense data objects
        const regularExpensesData = [
            @foreach (var expense in Model.ViewModel.RegularExpenses)
            {
                <text>
            {
                id: @expense.Id,
                name: '@Html.Raw(expense.Name.Replace("'", "\\'"))',
                amount: @expense.Amount,
                categoryId: @(expense.Category != null ? expense.Category.Id.ToString() : "null"),
                currency: '@expense.Currency',
                recurrence: '@expense.Recurrence',
                startDate: '@expense.StartDate.ToString("yyyy-MM-dd")',
                expenseType: '@expense.ExpenseType',
                familyMemberId: @(expense.FamilyMemberId?.ToString() ?? "null")
            },
                </text>
            }
        ];

        // Store full expense data for editing (including all schedules)
        const fullRegularExpensesData = [
            @foreach (var expense in await Model.GetAllRegularExpensesAsync())
            {
                <text>
            {
                id: @expense.Id,
                name: '@Html.Raw(expense.Name.Replace("'", "\\'"))',
                amount: @expense.Amount,
                categoryId: @(expense.Category != null ? expense.Category.Id.ToString() : "null"),
                currency: '@expense.Currency',
                recurrence: '@expense.Recurrence',
                startDate: '@expense.StartDate.ToString("yyyy-MM-dd")',
                expenseType: '@expense.ExpenseType',
                familyMemberId: @(expense.FamilyMemberId?.ToString() ?? "null"),
                schedules: [
                    @foreach (var schedule in expense.Schedules.OrderBy(s => s.StartYear * 12 + s.StartMonth))
                    {
                        <text>
                    {
                        startYear: @schedule.StartYear,
                        startMonth: @schedule.StartMonth,
                        endYear: @(schedule.EndYear?.ToString() ?? "null"),
                        endMonth: @(schedule.EndMonth?.ToString() ?? "null"),
                        amount: @schedule.Amount,
                        frequency: '@schedule.Frequency'
                    },
                        </text>
                    }
                ]
            },
                </text>
            }
        ];

        // One-time incomes data
        const oneTimeIncomesData = [
            @foreach (var income in Model.ViewModel.OneTimeIncomes)
            {
                <text>
            {
                id: @income.Id,
                name: '@Html.Raw(income.Name.Replace("'", "\\'"))',
                amount: @income.Amount,
                incomeSourceId: @(income.IncomeSourceId?.ToString() ?? "null"),
                currency: '@income.Currency',
                date: '@income.Date.ToString("yyyy-MM-dd")'
            },
                </text>
            }
        ];

        // Irregular expenses data
        const irregularExpensesData = [
            @foreach (var expense in Model.ViewModel.IrregularExpenses)
            {
                <text>
            {
                id: @expense.Id,
                name: '@Html.Raw(expense.Name.Replace("'", "\\'"))',
                amount: @expense.Amount,
                categoryId: @(expense.Category != null ? expense.Category.Id.ToString() : "null"),
                currency: '@expense.Currency',
                date: '@expense.Date.ToString("yyyy-MM-dd")',
                expenseType: '@expense.ExpenseType',
                familyMemberId: @(expense.FamilyMemberId?.ToString() ?? "null")
            },
                </text>
            }
        ];

        // Define functions globally
        window.editRegularExpense = function(expenseId) {
            console.log('editRegularExpense called with ID:', expenseId);

            // Find the expense data (use full data for complete schedule information)
            const expense = fullRegularExpensesData.find(e => e.id == expenseId);
            if (expense) {
                console.log('Found expense:', expense.name);
                document.getElementById('editExpenseId').value = expense.id;
                document.getElementById('editRegularExpenseName').value = expense.name;
                document.getElementById('editRegularExpenseAmount').value = expense.amount;
                document.getElementById('editRegularExpenseCategory').value = expense.categoryId || '';
                document.getElementById('editRegularExpenseCurrency').value = expense.currency;
                document.getElementById('editRegularExpenseFrequency').value = expense.recurrence;
                
                // Set expense type and family member
                document.getElementById('editRegularExpenseType').value = expense.expenseType || 'Family';
                document.getElementById('editRegularExpenseFamilyMember').value = expense.familyMemberId || '';
                
                // Toggle family member selection based on expense type
                toggleFamilyMemberSelection('editRegularExpense');
                
                // Set year and month from the start date
                const startDate = new Date(expense.startDate);
                document.getElementById('editRegularExpenseStartYear').value = startDate.getFullYear();
                document.getElementById('editRegularExpenseStartMonth').value = startDate.getMonth() + 1; // JavaScript months are 0-based

                // Populate schedule history table
                const schedulesBody = document.getElementById('editExpenseSchedulesBody');
                schedulesBody.innerHTML = '';

                const today = new Date().toISOString().split('T')[0]; // YYYY-MM-DD format

                expense.schedules.forEach(schedule => {
                    const row = document.createElement('tr');

                    // Start Date - display as Month Year
                    const startCell = document.createElement('td');
                    const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                    startCell.textContent = `${monthNames[schedule.startMonth - 1]} ${schedule.startYear}`;
                    row.appendChild(startCell);

                    // End Date
                    const endCell = document.createElement('td');
                    if (schedule.endYear && schedule.endMonth) {
                        endCell.textContent = `${monthNames[schedule.endMonth - 1]} ${schedule.endYear}`;
                    } else {
                        endCell.textContent = 'Ongoing';
                    }
                    row.appendChild(endCell);

                    // Amount
                    const amountCell = document.createElement('td');
                    amountCell.textContent = schedule.amount.toLocaleString('cs-CZ', { style: 'currency', currency: expense.currency });
                    row.appendChild(amountCell);

                    // Status
                    const statusCell = document.createElement('td');
                    const currentYear = new Date().getFullYear();
                    const currentMonth = new Date().getMonth() + 1; // JavaScript months are 0-based
                    
                    const scheduleStart = schedule.startYear * 12 + schedule.startMonth;
                    const scheduleEnd = (schedule.endYear && schedule.endMonth) 
                        ? schedule.endYear * 12 + schedule.endMonth 
                        : Number.MAX_SAFE_INTEGER;
                    const current = currentYear * 12 + currentMonth;
                    
                    const isCurrent = scheduleStart <= current && scheduleEnd >= current;
                    const isFuture = scheduleStart > current;
                    const isPast = scheduleEnd < current;

                    let statusBadge = '';
                    if (isCurrent) {
                        statusBadge = '<span class="badge bg-success">Current</span>';
                    } else if (isFuture) {
                        statusBadge = '<span class="badge bg-primary">Future</span>';
                    } else if (isPast) {
                        statusBadge = '<span class="badge bg-secondary">Past</span>';
                    }

                    statusCell.innerHTML = statusBadge;
                    row.appendChild(statusCell);

                    schedulesBody.appendChild(row);
                });
            }

            // Show the modal
            const modalElement = document.getElementById('editRegularExpenseModal');
            console.log('Modal element:', modalElement);
            if (modalElement) {
                const modal = new bootstrap.Modal(modalElement);
                modal.show();
                console.log('Modal shown successfully');
            } else {
                console.error('Modal element not found!');
            }
        };

        window.editIrregularExpense = function(expenseId) {
            console.log('editIrregularExpense called with ID:', expenseId);

            // Find the expense data
            const expense = irregularExpensesData.find(e => e.id == expenseId);
            if (expense) {
                console.log('Found expense:', expense.name);
                document.getElementById('editIrregularExpenseId').value = expense.id;
                document.getElementById('editIrregularExpenseName').value = expense.name;
                document.getElementById('editIrregularExpenseAmount').value = expense.amount;
                document.getElementById('editIrregularExpenseCategory').value = expense.categoryId || '';
                document.getElementById('editIrregularExpenseCurrency').value = expense.currency;
                document.getElementById('editIrregularExpenseDate').value = expense.date;
                
                // Set expense type and family member
                document.getElementById('editIrregularExpenseType').value = expense.expenseType || 'Family';
                document.getElementById('editIrregularExpenseFamilyMember').value = expense.familyMemberId || '';
                
                // Toggle family member selection based on expense type
                toggleFamilyMemberSelection('editIrregularExpense');
            }

            // Show the modal
            const modalElement = document.getElementById('editIrregularExpenseModal');
            console.log('Modal element:', modalElement);
            if (modalElement) {
                const modal = new bootstrap.Modal(modalElement);
                modal.show();
                console.log('Modal shown successfully');
            } else {
                console.error('Modal element not found!');
            }
        };

        // Month navigation function
        window.navigateMonth = function(direction) {
            const dateInput = document.getElementById('monthPicker');
            const currentDate = new Date(dateInput.value);
            
            // Add/subtract months
            currentDate.setMonth(currentDate.getMonth() + direction);
            
            // Format as YYYY-MM-DD
            const newDateStr = currentDate.toISOString().split('T')[0];
            
            // Update the input value
            dateInput.value = newDateStr;
            
            // Submit the form to navigate
            const form = dateInput.closest('form');
            form.submit();
        };

        window.navigateToCurrentMonth = function() {
            const dateInput = document.getElementById('monthPicker');
            const currentDate = new Date();
            
            // Get schedule configuration from server-rendered values
            const scheduleType = '@(Model.ViewModel.ScheduleConfig?.ScheduleType ?? "Calendar")';
            const startDay = parseInt('@(Model.ViewModel.ScheduleConfig?.StartDay ?? 1)');
            
            let targetDate;
            
            if (scheduleType === 'Custom') {
                // For custom schedules, find the start date of the period containing current date
                const currentYear = currentDate.getFullYear();
                const currentMonth = currentDate.getMonth(); // 0-based
                const currentDay = currentDate.getDate();
                
                if (currentDay >= startDay) {
                    // Current date is in the period starting this month
                    targetDate = new Date(currentYear, currentMonth, startDay);
                } else {
                    // Current date is in the period starting last month
                    if (currentMonth === 0) {
                        // January, so go to December of previous year
                        targetDate = new Date(currentYear - 1, 11, startDay);
                    } else {
                        targetDate = new Date(currentYear, currentMonth - 1, startDay);
                    }
                }
            } else {
                // For calendar months, use the first day of current month
                targetDate = new Date(currentDate.getFullYear(), currentDate.getMonth(), 1);
            }
            
            // Format as YYYY-MM-DD for the date input
            const targetDateStr = targetDate.toISOString().split('T')[0];
            
            // Update the input value
            dateInput.value = targetDateStr;
            
            // Submit the form to navigate
            const form = dateInput.closest('form');
            form.submit();
        };

        // Keyboard shortcuts for month navigation
        document.addEventListener('DOMContentLoaded', function() {
            document.addEventListener('keydown', function(event) {
                // Don't trigger shortcuts when user is typing in input fields
                if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA' || event.target.tagName === 'SELECT') {
                    return;
                }

                // Don't trigger shortcuts when modal is open
                if (document.querySelector('.modal.show')) {
                    return;
                }

                // Don't trigger shortcuts when modifier keys are pressed (Cmd, Ctrl, Alt, Shift)
                if (event.metaKey || event.ctrlKey || event.altKey || event.shiftKey) {
                    return;
                }

                switch(event.key) {
                    case 'ArrowLeft':
                    case 'p':
                    case 'P':
                        event.preventDefault();
                        navigateMonth(-1);
                        break;
                    case 'ArrowRight':
                    case 'n':
                    case 'N':
                        event.preventDefault();
                        navigateMonth(1);
                        break;
                    case 'c':
                    case 'C':
                    case 't':
                    case 'T':
                    case 'Home':
                        event.preventDefault();
                        navigateToCurrentMonth();
                        break;
                    case 'h':
                    case 'H':
                        event.preventDefault();
                        navigateToCurrentMonth();
                        break;
                }
            });
        });

        // One-time income functions
        window.editOneTimeIncome = function(incomeId) {
            console.log('editOneTimeIncome called with ID:', incomeId);

            // Find the income data
            const income = oneTimeIncomesData.find(i => i.id == incomeId);
            if (income) {
                console.log('Found income:', income.name);
                document.getElementById('editOneTimeIncomeId').value = income.id;
                document.getElementById('editOneTimeIncomeName').value = income.name;
                document.getElementById('editOneTimeIncomeAmount').value = income.amount;
                document.getElementById('editOneTimeIncomeSource').value = income.incomeSourceId || '';
                document.getElementById('editOneTimeIncomeCurrency').value = income.currency;
                document.getElementById('editOneTimeIncomeDate').value = income.date;
            }

            // Show the modal
            const modalElement = document.getElementById('editOneTimeIncomeModal');
            if (modalElement) {
                const modal = new bootstrap.Modal(modalElement);
                modal.show();
            }
        };

        window.deleteOneTimeIncome = function(incomeId) {
            if (confirm('Are you sure you want to delete this one-time income? This action cannot be undone.')) {
                // Use the hidden form
                const form = document.getElementById('deleteOneTimeIncomeForm');
                const incomeIdInput = document.getElementById('deleteOneTimeIncomeId');
                incomeIdInput.value = incomeId;
                form.submit();
            }
        };

        // Toggle family member selection visibility based on expense type
        window.toggleFamilyMemberSelection = function(prefix) {
            const expenseTypeSelect = document.getElementById(prefix + 'Type');
            const familyMemberContainer = document.getElementById(prefix + 'FamilyMemberContainer');
            const familyMemberSelect = document.getElementById(prefix + 'FamilyMember');
            
            if (expenseTypeSelect.value === 'Individual') {
                familyMemberContainer.style.display = 'block';
                familyMemberSelect.required = true;
            } else {
                familyMemberContainer.style.display = 'none';
                familyMemberSelect.required = false;
                familyMemberSelect.value = '';
            }
        };

        // Initialize tooltips
        document.addEventListener('DOMContentLoaded', function() {
            const tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'));
            const tooltipList = tooltipTriggerList.map(function(tooltipTriggerEl) {
                return new bootstrap.Tooltip(tooltipTriggerEl);
            });
        });
    </script>
    <script>
        (function () {
            function parseValue(type, value) {
                if (value == null) return '';
                if (type === 'number') {
                    const n = parseFloat(value);
                    return isNaN(n) ? 0 : n;
                }
                if (type === 'date') {
                    // Expect yyyy-MM-dd
                    const t = Date.parse(value);
                    return isNaN(t) ? 0 : t;
                }
                return ('' + value).toLowerCase();
            }

            function getCellValue(td, type) {
                const raw = td ? (td.getAttribute('data-sort-value') ?? td.textContent.trim()) : '';
                return parseValue(type, raw);
            }

            function clearOtherHeaders(ths, current) {
                ths.forEach(th => {
                    if (th !== current) {
                        th.removeAttribute('aria-sort');
                        const ind = th.querySelector('.sort-indicator');
                        if (ind) ind.remove();
                        th.dataset.order = '';
                    }
                });
            }

            function setIndicator(th, order) {
                let ind = th.querySelector('.sort-indicator');
                if (!ind) {
                    ind = document.createElement('span');
                    ind.className = 'sort-indicator ms-1';
                    th.appendChild(ind);
                }
                ind.innerHTML = order === 'asc' ? '<i class="bi bi-chevron-up"></i>' : '<i class="bi bi-chevron-down"></i>';
            }

            function makeTableSortable(tableId) {
                const table = document.getElementById(tableId);
                if (!table || !table.tHead) return;
                const ths = Array.from(table.tHead.querySelectorAll('th'));
                ths.forEach((th, idx) => {
                    const type = th.dataset.sort;
                    if (!type) return;
                    th.setAttribute('role', 'button');
                    th.tabIndex = 0;
                    th.title = 'Sort';
                    th.addEventListener('click', () => {
                        const tbody = table.tBodies[0];
                        if (!tbody) return;
                        const rows = Array.from(tbody.rows);
                        const currentOrder = th.dataset.order === 'asc' ? 'asc' : th.dataset.order === 'desc' ? 'desc' : '';
                        const newOrder = currentOrder === 'asc' ? 'desc' : 'asc';

                        clearOtherHeaders(ths, th);
                        th.dataset.order = newOrder;
                        th.setAttribute('aria-sort', newOrder === 'asc' ? 'ascending' : 'descending');
                        setIndicator(th, newOrder);

                        rows.sort((a, b) => {
                            const av = getCellValue(a.cells[idx], type);
                            const bv = getCellValue(b.cells[idx], type);
                            if (av < bv) return newOrder === 'asc' ? -1 : 1;
                            if (av > bv) return newOrder === 'asc' ? 1 : -1;
                            return 0;
                        });

                        // Re-append rows in new order
                        const frag = document.createDocumentFragment();
                        rows.forEach(r => frag.appendChild(r));
                        tbody.appendChild(frag);
                    });
                    th.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter' || e.key === ' ') {
                            e.preventDefault();
                            th.click();
                        }
                    });
                });
            }

            document.addEventListener('DOMContentLoaded', function () {
                makeTableSortable('regularExpensesTable');
                makeTableSortable('irregularExpensesTable');
                
                // Auto-sort irregular expenses table by date (newest first)
                const irregularTable = document.getElementById('irregularExpensesTable');
                if (irregularTable && irregularTable.tHead) {
                    const dateHeader = irregularTable.tHead.querySelectorAll('th')[0]; // Date column is first
                    if (dateHeader && dateHeader.dataset.sort === 'date') {
                        // Trigger sort twice to get descending order (newest first)
                        dateHeader.click();
                        dateHeader.click();
                    }
                }
            });
        })();
    </script>
}
